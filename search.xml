<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS事件循环</title>
      <link href="/2024/06/27/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
      <url>/2024/06/27/JS%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="JS事件循环"><a href="#JS事件循环" class="headerlink" title="JS事件循环"></a>JS事件循环</h1><p>本文主要参考自：</p><p><a href="https://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a> </p><p><a href="https://juejin.cn/post/6844903471280291854" target="_blank" rel="noopener">理解 JavaScript 中的 macrotask 和 microtask</a></p><h2 id="JavaScript单线程"><a href="#JavaScript单线程" class="headerlink" title="JavaScript单线程"></a>JavaScript单线程</h2><p>JavaScript语言的一大特点就是单线程，也就是同一时间只能做一件事。这与其用途有关，JS的主要任务是和用户互动以及操作DOM。这决定了它只能是单线程，否则会引起复杂的同步问题。</p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>单线程意味着所有任务需要排队，前一个任务完成，后一个才能开始。由于部分任务例如IO设备很慢，JS设计者意识到主线可以不管IO设备，挂起等待中的任务，先运行排在后面的。等IO返回了结果，再回头把挂起的任务继续，这就是同步任务（synchronous）和异步任务（asynchronous）。</p><p>具体来说，异步任务的运行机制如下：</p><ol><li>所有同步任务都在主进程上执行，形成一个<strong>执行栈</strong></li><li>主线程之外还存在一个“<strong>任务队列</strong>”。只要<u>异步任务有了运行结果</u>，就在“任务队列”中放置一个事件</li><li>一旦<strong>执行栈</strong>中所有同步任务<u>执行完毕</u>，系统就会读取“<strong>任务队列</strong>”。对应的异步任务结束等待状态，进入执行栈，开始执行</li><li>主线程不断重复以上三步</li></ol><p><img src="bg2014100801.jpg" alt="bg2014100801" style="zoom:80%;" /></p><h2 id="事件和回调函数"><a href="#事件和回调函数" class="headerlink" title="事件和回调函数"></a>事件和回调函数</h2><p>任务队列是一个先进先出的数据结构。异步任务必须指定回调函数，当主进程开始执行异步任务，就是执行对应的回调函数。</p><p>:warning:</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p><img src="bg2014100802.png" alt="bg2014100802" style="zoom:80%;" /></p><ul><li>主线程运行的时候，产生堆（heap）和栈（stack）</li><li>栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）</li><li>只要栈中的代码执行完毕，主线程就会去读取”任务队列”</li><li>依次执行那些事件所对应的回调函数</li></ul><p>注意：执行栈中的代码（同步任务）总是在读取任务列表（异步任务）之前执行！</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>除了放置异步任务的事件，“任务队列”还可以防止定时事件，即制定某些代码在多少时间之后执行。</p><p><code>setTimeout()</code>接受两个参数，第一个是回调函数，第二个是推迟执行的秒数。<code>setTimeout(fn, o)</code>的含义是，指定某个任务在主线程最早可得的空闲时间执行。<strong>他在“任务队列”的尾部添加一个事件，因此要等到同步任务和“任务队列”现有的事件都处理完，才会得到执行</strong></p><h2 id="Macrotasks-和-Microtasks"><a href="#Macrotasks-和-Microtasks" class="headerlink" title="Macrotasks 和 Microtasks"></a>Macrotasks 和 Microtasks</h2><p>Macrotasks 和 Microtasks都属于异步任务：</p><ul><li>macrotasks: <code>setTimeout</code>, <code>setInterval</code>, I/O…</li><li>microtasks: <code>Promises</code>, <code>process.nextTick</code>…</li></ul><p>“任务队列”分为macrotasks 和 microtasks，每一次事件循环中，macrotasks只会提取一个执行，而microtasks会一直提取，直到清空。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript设计模式</title>
      <link href="/2024/06/22/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/06/22/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>本文参考自<a href="https://github.com/zy445566/design-pattern-in-javascript/tree/master" target="_blank" rel="noopener">JavaScript中的设计模式</a></p><blockquote><p>不使用设定模式，照样可以进行需求开发。但后果是：给后期维护、开发、迭代带来麻烦</p></blockquote><p>常见的设计模式：</p><div class="table-container"><table><thead><tr><th>模式类型</th><th>设计模式</th></tr></thead><tbody><tr><td>创建型模式</td><td>单例模式、工厂模式、建造者模式</td></tr><tr><td>结构型模式</td><td>装饰者模式、代理模式</td></tr><tr><td>行为型模式</td><td>策略模式、观察者模式</td></tr></tbody></table></div><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>简单来说就是<strong>一个实例只生产一次</strong>。</p><p>好处是对于频繁使用且可以重复使用的对象，极大地减少了内存消耗。包括：</p><ul><li>懒汉式写法：使用时才初始化</li><li>饿汉式写法：先初始化，使用时直接给</li></ul><p>更推荐懒汉式写法，饿汉式可能产生没必要的垃圾</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 防止调用new初始化</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span>.target != <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> errorMsg = <span class="string">"This is single object,Can't use keyword new!"</span>;</span><br><span class="line">            <span class="keyword">const</span> tipMsg = <span class="string">"You should use method getInstance to get instance。"</span>;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`\n<span class="subst">$&#123;errorMsg&#125;</span>\n<span class="subst">$&#123;tipMsg&#125;</span>`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> getInstance()&#123;</span><br><span class="line">        <span class="comment">// 生产单例</span></span><br><span class="line">        <span class="keyword">if</span>(SingleObject.instance) &#123;</span><br><span class="line">            <span class="keyword">return</span> SingleObject.instance;</span><br><span class="line">        &#125;</span><br><span class="line">        SingleObject.instance = &#123;&#125;;</span><br><span class="line">        SingleObject.instance.__proto__ = SingleObject.prototype;</span><br><span class="line">        <span class="keyword">return</span> SingleObject.instance;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    showMessage()&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = SingleObject.getInstance();</span><br><span class="line">instance.showMessage();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * output:</span></span><br><span class="line"><span class="comment"> * Hello World!</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单来说，就是<strong>不直接采用new生成实例，而是统一通过工厂加工生成</strong>。</p><p>好处是：比如实例的生产比较复杂，或者说生成实例后还需要额外加工，工厂模式提供了统一的出入口，也方便日后对实例的修改。</p><p>例如，首先我们拥有很多图形类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    draw() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I'm a circle"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    draw() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I'm a rectangle"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">    draw() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I'm a square"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们建立一个专门生产图形的工厂：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>&#123;</span><br><span class="line">    getShape(shapeType)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(shapeType) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'CIRCLE'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'RECTANGLE'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'SQUARE'</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要使用时，只需new一个工厂实例，根据字符串生成所需要的类。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p><strong>让简单的对象通过组合的方式构造多种复杂对象</strong>。</p><p>这是一种创建复杂对象的最佳实践。尤其是复杂对象多变的情况下，通过基础组件来组合，在基础组件变更时，多种依赖于基础组件的复杂组件也能方便变更，而不需要更改多种不同的复杂组件。</p><p>套餐类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">const</span> items = [];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 为什么不用Proxy而使用defineProperty</span></span><br><span class="line"><span class="comment">         * 因为Proxy虽然实现和defineProperty类似的功能</span></span><br><span class="line"><span class="comment">         * 但是在这个场景下，语意上是定义属性，而不是需要代理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="built_in">Reflect</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'items'</span>, &#123;</span><br><span class="line">            <span class="keyword">get</span>:()=&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.__proto__ != Meal.prototype) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'items is private!'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> items;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">    addItem(item)&#123;</span><br><span class="line">        <span class="keyword">this</span>.items.push(item);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    getCost()&#123;</span><br><span class="line">       <span class="keyword">let</span> cost = <span class="number">0.0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items) &#123;</span><br><span class="line">          cost += item.price();</span><br><span class="line">       &#125;        </span><br><span class="line">       <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    showItems()&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="keyword">this</span>.items) &#123;</span><br><span class="line">          <span class="keyword">const</span>  nameStr = <span class="string">"Item : "</span>+item.name();</span><br><span class="line">          <span class="keyword">const</span>  packStr = <span class="string">"Packing : "</span>+item.packing().pack();</span><br><span class="line">          <span class="keyword">const</span>  priceStr = <span class="string">"Price : "</span>+item.price();</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;nameStr&#125;</span>,<span class="subst">$&#123;packStr&#125;</span>,<span class="subst">$&#123;priceStr&#125;</span>`</span>);</span><br><span class="line">       &#125;        </span><br><span class="line">    &#125;   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>套餐建造者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MealBuilder</span> </span>&#123;</span><br><span class="line">    prepareVegMeal ()&#123;</span><br><span class="line">       <span class="keyword">const</span> meal = <span class="keyword">new</span> Meal();</span><br><span class="line">       meal.addItem(<span class="keyword">new</span> VegBurger());</span><br><span class="line">       meal.addItem(<span class="keyword">new</span> Coke());</span><br><span class="line">       <span class="keyword">return</span> meal;</span><br><span class="line">    &#125;</span><br><span class="line">    prepareNonVegMeal ()&#123;</span><br><span class="line">        <span class="keyword">const</span> meal = <span class="keyword">new</span> Meal();</span><br><span class="line">       meal.addItem(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">       meal.addItem(<span class="keyword">new</span> Pepsi());</span><br><span class="line">       <span class="keyword">return</span> meal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>装饰器模式实现了不改变原有对象，在原有对象上实现功能的添加。是一种对原有对象的包装。</p><p>例如：现在有矩形和圆形类，我们希望在形状上实现一些特殊功能，但不改变原来的类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    draw() &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"Shape: Rectangle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    draw() &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"Shape: Circle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用装饰器实现，假设我们要给现状增加颜色功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedShapeDecorator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(decoratedShape) &#123;</span><br><span class="line">       <span class="keyword">this</span>.decoratedShape = decoratedShape;    </span><br><span class="line">    &#125;</span><br><span class="line">    draw() &#123;</span><br><span class="line">       <span class="keyword">this</span>.decoratedShape.draw();        </span><br><span class="line">       <span class="keyword">this</span>.setRedBorder();</span><br><span class="line">    &#125;</span><br><span class="line">    setRedBorder()&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">"Border Color: Red"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>用一个新的类代理另一个类，这种模式一般用于方法的前置操作或拦截</strong>。</p><p>简单来说，就是中介、寄卖、经纪人等角色的作用，对外暴露的并不是原对象，而是一个操控原对象的代理对象。</p><p>例如我们有一个原本的类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fileName)&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        <span class="keyword">this</span>.loadFromDisk(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">    display() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Displaying "</span> + <span class="keyword">this</span>.fileName);</span><br><span class="line">    &#125;</span><br><span class="line">    loadFromDisk(fileName)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Loading "</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不想初始化就载入文件，可以用一个类来代理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(fileName)&#123;</span><br><span class="line">       <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line">    display() &#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">this</span>.realImage == <span class="literal">null</span>)&#123;</span><br><span class="line">          <span class="keyword">this</span>.realImage = <span class="keyword">new</span> RealImage(<span class="keyword">this</span>.fileName);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">this</span>.realImage.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p><strong>根据传入类的策略，进行不同的操作</strong></p><p>好处：策略和策略之间实现解耦，从而减少一些if…else…操作</p><p>首先我们定义几种不同的策略：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> </span>&#123;</span><br><span class="line">    doOperation(num1, num2) &#123;</span><br><span class="line">       <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> </span>&#123;</span><br><span class="line">    doOperation(num1, num2) &#123;</span><br><span class="line">       <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> </span>&#123;</span><br><span class="line">    doOperation(num1, num2) &#123;</span><br><span class="line">       <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义根据策略改变行为的上下文：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(strategy)&#123;</span><br><span class="line">       <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    executeStrategy(num1, num2)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.strategy.doOperation(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就可以根据策略的不同，执行不同的操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());    </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"10 + 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubstract());      </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"10 - 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());    </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"10 * 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * output:</span></span><br><span class="line"><span class="comment"> * 10 + 5 = 15</span></span><br><span class="line"><span class="comment"> * 10 - 5 = 5</span></span><br><span class="line"><span class="comment"> * 10 * 5 = 50</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><strong>当一个对象和另外几个对象产生关联时，在这个对象发生改变事实现通知相应对象变更</strong></p><p>好处：对于对象和对象的<strong>关系</strong>中，可以通过这种方式来降低耦合，同时在代码的使用上也更加直观</p><p>先建立观察者模式的模型，即构建队列再进行通知</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.observers = [];</span><br><span class="line">    &#125;</span><br><span class="line">    getState() &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line">    setState(state) &#123;</span><br><span class="line">       <span class="keyword">this</span>.state = state;</span><br><span class="line">       <span class="keyword">this</span>.notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    attach(observer)&#123;</span><br><span class="line">       <span class="keyword">this</span>.observers.push(observer);      </span><br><span class="line">    &#125;</span><br><span class="line">    notifyAllObservers()&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">const</span> observer <span class="keyword">of</span> <span class="keyword">this</span>.observers) &#123;</span><br><span class="line">          observer.update();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>然后当对象初始化后加入观察者模型中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(subject)&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Binary String: "</span> </span><br><span class="line">        + <span class="keyword">this</span>.subject.getState().toString(<span class="number">2</span>) ); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OctalObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(subject)&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Octal String: "</span> </span><br><span class="line">        + <span class="keyword">this</span>.subject.getState().toString(<span class="number">8</span>) ); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HexObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(subject)&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    update() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">"Hex String: "</span> </span><br><span class="line">        + <span class="keyword">this</span>.subject.getState().toString(<span class="number">16</span>) ); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用时，只需要在观察者和对应类初始化完成即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> HexObserver(subject);</span><br><span class="line"><span class="keyword">new</span> OctalObserver(subject);</span><br><span class="line"><span class="keyword">new</span> BinaryObserver(subject);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"First state change: 15"</span>);   </span><br><span class="line">subject.setState(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Second state change: 10"</span>);  </span><br><span class="line">subject.setState(<span class="number">10</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * output:</span></span><br><span class="line"><span class="comment"> * First state change: 15</span></span><br><span class="line"><span class="comment"> * Hex String: f</span></span><br><span class="line"><span class="comment"> * Octal String: 17</span></span><br><span class="line"><span class="comment"> * Binary String: 1111</span></span><br><span class="line"><span class="comment"> * Second state change: 10</span></span><br><span class="line"><span class="comment"> * Hex String: a</span></span><br><span class="line"><span class="comment"> * Octal String: 12</span></span><br><span class="line"><span class="comment"> * Binary String: 1010</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Fontend Notes 3] JavaScript</title>
      <link href="/2024/06/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
      <url>/2024/06/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<p>本文参考<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript" target="_blank" rel="noopener">MDN 文档 JavaScript部分</a></p><h2 id="JavaScript第一步"><a href="#JavaScript第一步" class="headerlink" title="JavaScript第一步"></a>JavaScript第一步</h2><h3 id="什么是JavaScript"><a href="#什么是JavaScript" class="headerlink" title="什么是JavaScript"></a>什么是JavaScript</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>JavaScript是一种<strong>脚本编程语言</strong>，可以在网页上实现复杂的功能</p><ul><li>HTML是一种标记语言，用来结构化我们的网页内容并赋予内容含义</li><li>CSS是一种样式规则语言，可将样式应用于HTML内容</li><li>JavaScript是一种脚本语言，用来创建动态更新的内容，控制多媒体，制作图像动画等等</li></ul><h4 id="它可以做什么？"><a href="#它可以做什么？" class="headerlink" title="它可以做什么？"></a>它可以做什么？</h4><p>JavaScript语言的核心包含一些普遍的编程特性，可以做到：</p><ul><li>在变量中存储值</li><li>操作一段文本（string）</li><li>运行代码以响应网页中发生的特定事件</li></ul><p>在语言核心之上，JavaScript构建了应用程序接口（application programming interface, API）为代码提供了额外的能力。</p><p>API是已经构建好的一套代码组件，可以让开发者实现原本很难的程序。API通常分为两类：</p><ul><li><strong>浏览器API</strong>：内建于web浏览器中，可以将数据从周边计算机环境中筛选出来，还可以做实用的复杂工作，例如：<ul><li>文档对象模型 API，能通过创建、移出和修改HTML，为页面动态应用新样式等手段，操作HTML和CSS。比如页面出现弹窗，这就是DOM在运行</li><li>地理位置API，可以获取地理信息</li><li>画布（canvas）和WebGL API，可以创建生动的2D和3D图像</li><li>HTMLMediaElement和WebRTC等影音类API，可以在网页中直接播放音乐和影片等等</li></ul></li><li><strong>第三方API</strong>：没有默认嵌入浏览器中，需要在网上取得它们的代码和信息，例如：<ul><li>新浪微博API，可以在网站上展示最新推文</li><li>高德地图API，可以在网站嵌入定制的地图</li></ul></li></ul><h4 id="它在页面上做了什么？"><a href="#它在页面上做了什么？" class="headerlink" title="它在页面上做了什么？"></a>它在页面上做了什么？</h4><p>JavaScript的一个非常常见的用途是通过DOM API动态修改HTML和CSS，以更新用户界面。:warning:注意如果JavaScript先于要修改的HTML和CSS加载和运行，则可能发送错误。</p><p><strong>JavaScript的运行次序</strong></p><p>通常会按从上往下的顺序执行这段代码，需要注意代码书写的顺序，否则可能会出现<code>TypeError: para is undefined</code></p><p><strong>解释代码 vs 编译代码</strong></p><ul><li>解释型语言，代码自上而下运行，且实时返回运行结果。代码在由浏览器执行前，不要转换为其他形式，直接以文本格式被接收和处理</li><li>编译型语言，需要先将代码转化（编译）为另一种形式才能运行。</li></ul><p>JavaScript是轻量级解释型语言。几乎所有的JavaScript转换器都运用了一种叫即时编译的技术，当源代码执行时，会被编译成二进制的格式，使代码运行速度更快。尽管如此，JavaScript仍是解释型语言，因为编译发生在代码运行中，而非之前</p><p><strong>服务器端代码 vs 客户端代码</strong></p><ul><li>客户端代码就是运行在用户电脑上的代码。在浏览一个网页时，它的客户端代码就会被下载，然后由浏览器来运行并展示</li><li>服务器代码在服务器上运行，运行结果由浏览器下载并展示。流行的服务器端web语言包括：PHP、Python、Ruby、ASP.NET，JavaScript也可作为服务器端语言，比如现在流行的Node.js环境</li></ul><h4 id="如何向页面添加JavaScript？"><a href="#如何向页面添加JavaScript？" class="headerlink" title="如何向页面添加JavaScript？"></a>如何向页面添加JavaScript？</h4><p><strong>1. 内部JavaScript</strong></p><p>在<code>&lt;/head&gt;</code>标签结束前插入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// 在此编写 JavaScript 代码</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2. 外部JavaScript</strong></p><p>可以把JavaScript代码放置在一个外部文件中，扩展名为.js</p><p>将<code>&lt;script&gt;</code>元素替换为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"xxx.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3. 内联JavaScript处理器</strong></p><p>在HTML内可能包含JavaScript代码调用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"createParagraph()"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4. addEventListener</strong></p><p>通过<code>querySelectorAll()</code>函数，选择页面上所有按钮，遍历这些按钮，使用<code>addEventListener()</code>为每个按钮分配一个处理器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buttons = <span class="built_in">document</span>.querySelectorAll(<span class="string">"button"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; buttons.length; i++) &#123;</span><br><span class="line">  buttons[i].addEventListener(<span class="string">"click"</span>, createParagraph);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>async 和 defer</strong></p><p>用于解决脚本阻塞问题：</p><ul><li><code>async</code>：遇到async脚本时，浏览器不会阻止页面渲染，而是直接下载然后运行。一旦下载完成，脚本就会执行，阻止页面渲染。</li><li><code>defer</code>：使用defer属性加载的脚本将按照它们在页面上出现的顺序加载。在页面内容全部加载完成前，脚本不会运行</li></ul><p><img src="async-defer.jpg" alt="async-defer"></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h4><p><strong>var 和 let的区别</strong></p><ul><li>var存在变量提升，可以先初始化再声明。let不行</li><li>var可以多次声明同名变量。let不行</li></ul><p>let是更新的版本，更加规范</p><h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><ul><li><p>Number</p></li><li><p>String</p></li><li><p>Boolean</p></li><li><p>Array</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myNameArray = [<span class="string">"christ"</span>, <span class="string">"bob"</span>, <span class="string">"jim"</span>];</span><br></pre></td></tr></table></figure></li><li><p>Object</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dog = &#123;<span class="attr">name</span>: <span class="string">"spot"</span>, <span class="attr">breed</span>: <span class="string">"dalimatian"</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h4><p>JavaScript是一种“动态类型语言”，这意味着不需要指定变量将包含什么数据类型</p><h3 id="JavaScript中的字符串"><a href="#JavaScript中的字符串" class="headerlink" title="JavaScript中的字符串"></a>JavaScript中的字符串</h3><h4 id="嵌入JavaScript"><a href="#嵌入JavaScript" class="headerlink" title="嵌入JavaScript"></a>嵌入JavaScript</h4><p>在<strong>模版字面量</strong>中，可以在<code>${}</code>中包装JavaScript变量或表达式，其结果将被包含在字符串中：</p><blockquote><p>模版字面量：用反引号（`）包裹的字面量</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">"克里斯"</span>;</span><br><span class="line"><span class="keyword">const</span> greeting = <span class="string">`你好，<span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(greeting); <span class="comment">// "你好，克里斯"</span></span><br></pre></td></tr></table></figure><h4 id="数字与字符串"><a href="#数字与字符串" class="headerlink" title="数字与字符串"></a>数字与字符串</h4><ul><li><code>Number()</code>函数会将其参数转换为数字</li><li><code>String()</code>函数会将其参数转换为字符串</li></ul><h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><p><strong>获取长度</strong></p><p>使用<code>length</code>属性，如<code>string1.length</code></p><p><strong>检索特定字符串字符</strong></p><p>如string1[0]；</p><p><strong>查找子字符串</strong></p><p><code>indexof()</code>，例如<code>string1.indexof(&quot;amy&quot;);</code></p><p>查找失败时返回-1</p><p><strong>分割字符串</strong></p><p><code>slice()</code>，需要给出开始结尾的字符位置：<code>string1.slice(1, 3)</code>，也可以只给出开始位置，提取该字符后的子串：<code>string1.slice(2)</code></p><p><strong>转换大小写</strong></p><p><code>toLowerCase()</code>和<code>toUpperCase()</code>，如<code>string1.toLowerCase()</code></p><p><strong>字符串部分替换</strong></p><p><code>replace()</code>，如<code>string1.replace(&quot;and&quot;, &quot;or&quot;);</code></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><ol><li>字符串与数组转换<ul><li><code>split()</code></li><li><code>join()</code>：指定分隔符；<code>toString()</code></li></ul></li><li>添加和删除数组项<ul><li><code>push()</code>：添加一个或多个元素到末尾</li><li><code>pop()</code>：删除最后一个元素</li></ul></li></ol><h2 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><p><strong>可选参数</strong></p><p>可以在函数名称后添加<code>=</code>，然后添加默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">name = <span class="string">"克里斯"</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`你好，<span class="subst">$&#123;name&#125;</span>！`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello(<span class="string">"阿里"</span>); <span class="comment">// 你好，阿里！</span></span><br><span class="line">hello(); <span class="comment">// 你好，克里斯！</span></span><br></pre></td></tr></table></figure><h4 id="匿名函数和箭头函数"><a href="#匿名函数和箭头函数" class="headerlink" title="匿名函数和箭头函数"></a>匿名函数和箭头函数</h4><p><strong>匿名函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"你好"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的匿名函数是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"你好"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>匿名函数常用与一个函数希望接收另一个函数作为参数（回调函数）</p><p>例如，在以下例子中，可以将函数提出来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logKey</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`You pressed "<span class="subst">$&#123;event.key&#125;</span>".`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">textBox.addEventListener(<span class="string">"keydown"</span>, logKey);</span><br></pre></td></tr></table></figure><p>也可以直接将匿名函数传入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">textBox.addEventListener(<span class="string">"keydown"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`You pressed "<span class="subst">$&#123;event.key&#125;</span>".`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>箭头函数</strong></p><p>可以用<code>(event) =&gt;</code>代替<code>function(event)</code></p><p>如果函数只包含一行return语句，可以省略，从而隐式地返回表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> originals = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> doubled = originals.map(<span class="function"><span class="params">item</span> =&gt;</span> item * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(doubled); <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><h3 id="事件介绍"><a href="#事件介绍" class="headerlink" title="事件介绍"></a>事件介绍</h3><h4 id="什么是事件？"><a href="#什么是事件？" class="headerlink" title="什么是事件？"></a>什么是事件？</h4><p>事件是发生在你正在编程的系统中的事情，当事件发生时，系统产生某种信号，并提供一种机制，可以自动采取某种行动</p><p>为了对一个事件做出反应，需要给它添加一个事件处理器</p><h4 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a>addEventListener()</h4><p>这是常用的添加事件处理器的机制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">"button"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (number + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> rndCol = <span class="string">`rgb(<span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>)`</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.style.backgroundColor = rndCol;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>“click”表示我们要监听的事件，存在很多值，如：鼠标移到按钮上“mouseover”，用户按下一个键“keydown”</li><li>还传入了一个回调函数，表示事件发生时调用的函数。把处理函数作为一个单独的具名函数也是可以的</li></ul><p><strong>监听其他事件</strong></p><ul><li><code>focus</code>和<code>blur</code>：当按钮被聚焦或失焦时</li><li><code>dbclick</code>：双击</li><li><code>mouseover</code>和<code>mouseout</code>：当鼠标指针在按钮上悬停或移出</li></ul><p><strong>在单个事件上添加多个监听器</strong></p><p>事件触发时，所有处理器函数都会运行</p><h4 id="其他事件监听器机制"><a href="#其他事件监听器机制" class="headerlink" title="其他事件监听器机制"></a>其他事件监听器机制</h4><p><strong>事件处理器属性</strong></p><p>可以触发事件的对象通常也有属性，其名称是on，后面加上事件的名称，这被称为事件处理器属性。为了监听事件，可以将处理函数分配给该属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">"button"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (number + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> rndCol = <span class="string">`rgb(<span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>)`</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.style.backgroundColor = rndCol;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于事件处理器属性，不能为一个事件添加一个以上的处理函数，因为后面的定义会覆写较早设置的属性</p><p><strong>内联事件处理器</strong></p><p><u>将HTML和JavaScript混合不是一种好方法</u></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"bgChange()"</span>&gt;</span>按下我<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p>有时在事件处理函数内部，可能会看到一个参数，例如<code>event</code>、<code>evt</code>、<code>e</code>。这被称为<strong>事件对象</strong>，它被自动地传递给事件处理函数，已提供额外的功能和信息。例如之前的随机颜色示例，可以写作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">"button"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (number + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bgChange</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> rndCol = <span class="string">`rgb(<span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;random(<span class="number">255</span>)&#125;</span>)`</span>;</span><br><span class="line">  e.target.style.backgroundColor = rndCol;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, bgChange);</span><br></pre></td></tr></table></figure><p><code>e.target</code>指的是按钮本身，也就是事件刚发生的元素的引用，所以在这个例子中，按钮随机设置颜色，而不是之前的页面</p><p><strong>事件对象的额外属性</strong></p><p>一些事件对象添加了与该特定类型的事件相关的额外属性。例如，<code>keydown</code>事件在用户按下一个键时发生。它的事件对象是<code>KeyboardEvent</code>，有一个<code>key</code>属性，告诉你哪个键被按下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"textBox"</span> <span class="attr">type</span>=<span class="string">"text"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"output"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textBox = <span class="built_in">document</span>.querySelector(<span class="string">"#textBox"</span>);</span><br><span class="line"><span class="keyword">const</span> output = <span class="built_in">document</span>.querySelector(<span class="string">"#output"</span>);</span><br><span class="line">textBox.addEventListener(<span class="string">"keydown"</span>, (event) =&gt; &#123;</span><br><span class="line">  output.textContent = <span class="string">`You pressed "<span class="subst">$&#123;event.key&#125;</span>".`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h4><p>有时我们希望事件不执行它的默认行为。例如用户未正确提交数据时，阻止信息提交给服务器，并反馈错误提示。</p><p>可以在事件对象上调用<code>preventDefault()</code>函数</p><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>事件冒泡描述了浏览器如何处理针对嵌套元素的事件</p><p><strong>在父元素上设置监听器</strong></p><p>点击按钮时，也隐含地点击了它的父元素</p><p><strong>冒泡示例</strong></p><p>如果给按钮及其父元素上同时添加事件处理器，其结果是：</p><ul><li>先触发按钮上的单击事件</li><li>然后是按钮的父元素（<code>&lt;div&gt;</code>元素）</li><li>然后是<code>&lt;div&gt;</code>的父元素（<code>&lt;body&gt;</code>元素）</li></ul><p>可以视作事件从被点击的最里面的元素<u>冒泡而出</u></p><h2 id="JavaScript对象介绍"><a href="#JavaScript对象介绍" class="headerlink" title="JavaScript对象介绍"></a>JavaScript对象介绍</h2><h3 id="JavaScript对象基础"><a href="#JavaScript对象基础" class="headerlink" title="JavaScript对象基础"></a>JavaScript对象基础</h3><h4 id="对象基础"><a href="#对象基础" class="headerlink" title="对象基础"></a>对象基础</h4><p>构造一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: [<span class="string">"Bob"</span>, <span class="string">"Smith"</span>],</span><br><span class="line">  age: <span class="number">32</span>,</span><br><span class="line">  bio() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name[<span class="number">0</span>]&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.name[<span class="number">1</span>]&#125;</span> 现在 <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span> 岁了。`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  introduceSelf() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`你好！我是 <span class="subst">$&#123;<span class="keyword">this</span>.name[<span class="number">0</span>]&#125;</span>。`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="点表示法和括号表示法"><a href="#点表示法和括号表示法" class="headerlink" title="点表示法和括号表示法"></a>点表示法和括号表示法</h4><ul><li>点表示法：`person.age</li><li>括号表示法：<code>person[&quot;age&quot;]</code></li></ul><h4 id="设置对象成员"><a href="#设置对象成员" class="headerlink" title="设置对象成员"></a>设置对象成员</h4><p>除了查询对象成员外，也可以通过声明设置对象成员的值：</p><p><code>person.age = 45</code></p><p>也可以创建新的成员：</p><p><code>person[&quot;eyes&quot;] = &quot;hazel&quot;</code></p><h4 id="this的含义"><a href="#this的含义" class="headerlink" title="this的含义"></a>this的含义</h4><p>关键字<code>this</code>指向了当前代码运行时的对象，这里指<code>person</code>对象。<code>this</code>可以让你对每个创建的对象都使用相同的方法定义，需要借助<strong>构造函数</strong></p><h4 id="构造函数介绍"><a href="#构造函数介绍" class="headerlink" title="构造函数介绍"></a>构造函数介绍</h4><blockquote><p>对象字面量：包裹在一对花括号中的一个对象的多个“属性名：属性值”列表</p></blockquote><p>使用对象字面量在只需要创建一个对象时是可以的，但如果需要创建多个对象就不够用了</p><p>这种情况下，我们可以使用<strong>构造函数</strong>。当我们调用构造函数时，将会：</p><ul><li>创建一个新对象</li><li>将<code>this</code>绑定到新对象</li><li>运行构造函数中的代码</li><li>返回新对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.introduceSelf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`你好！我是 <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>。`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要将<code>Person()</code>作为构造函数调用，我们使用<code>new</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> salva = <span class="keyword">new</span> Person(<span class="string">"Salva"</span>);</span><br><span class="line">salva.name;</span><br><span class="line">salva.introduceSelf();</span><br><span class="line"><span class="comment">// "你好！我是 Salva。"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> frankie = <span class="keyword">new</span> Person(<span class="string">"Frankie"</span>);</span><br><span class="line">frankie.name;</span><br><span class="line">frankie.introduceSelf();</span><br><span class="line"><span class="comment">// "你好！我是 Frankie。"</span></span><br></pre></td></tr></table></figure><h3 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h3><p>原型是JavaScript对象相互继承特性的机制。</p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><blockquote><p>在控制台输入对象名称，后跟一个小数点，会列出一系列属性。其中有许多并不是我们定义的属性，但可以成功调用。那么这些属性是哪来的？</p></blockquote><p>JavaScript中所有对象都有一个内置属性，称为它的prototype（原型）。它本身是一个对象，故原型对象也会有它自己的原型，逐渐构成<strong>原型链</strong>。终止与拥有<code>null</code>作为原型的对象</p><p>当你视图访问一个对象的属性时，如果在对象本身找不到该属性，就会在原型中搜索。以此类推，直到找到属性，或者到达链的末端（返回<code>undefined</code>）</p><h4 id="属性遮蔽"><a href="#属性遮蔽" class="headerlink" title="属性遮蔽"></a>属性遮蔽</h4><p>若你在一个对象中定义了一个属性，但该对象的原型中存在同名属性：</p><p>浏览器会先在对象中寻找方法，没有的话才会再原型中查找，因此会调用对象中定义的属性</p><h4 id="设置原型"><a href="#设置原型" class="headerlink" title="设置原型"></a>设置原型</h4><p><strong>使用Object.create</strong></p><p><code>Object.create()</code>方法创建一个新的对象，并允许指定一个对象作为原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> personPrototype = &#123;</span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello!"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> carl = <span class="built_in">Object</span>.create(personPrototype);</span><br><span class="line">carl.greet(); <span class="comment">// hello!</span></span><br></pre></td></tr></table></figure><p><strong>使用构造函数</strong></p><p>在JavaScript中，所有函数都有一个名为<code>prototype</code>的属性。当你调用一个函数作为构造函数时，该属性被设置为新构造对象的原型</p><p>因此，我们可以通过设置构造函数<code>prototype</code>属性，保证所有由该构造函数创建的对象，都被赋予设定的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> personPrototype = &#123;</span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`你好，我的名字是 <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>！`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Person.prototype, personPrototype);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="comment">// Person.prototype.greet = personPrototype.greet;</span></span><br></pre></td></tr></table></figure><h4 id="原型与继承"><a href="#原型与继承" class="headerlink" title="原型与继承"></a>原型与继承</h4><blockquote><p>原型是一个强大且灵活的功能，使得重用代码和组合对象成为可能</p></blockquote><p>原型支持某种意义的继承，这是面向对象编程的一个特点</p><h3 id="面向对象编程基本概念"><a href="#面向对象编程基本概念" class="headerlink" title="面向对象编程基本概念"></a>面向对象编程基本概念</h3><p>面向对象编程主要包括三个概念：类与实例、继承、封装。</p><p>它将一个系统抽象为许多对象的集合，对象包括数据和方法。</p><p>一个对象可以向其他部分的代码提供公共接口，从而其他部分代码可以执行该对象的特定操作，但不需要关心内部是如何完成任务的，保证了对象内部状态的私有性</p><h4 id="类与实例"><a href="#类与实例" class="headerlink" title="类与实例"></a>类与实例</h4><blockquote><p>当我们使用面向对象编程对一个问题进行建模时，我们会创建一系列抽象的定义，代表系统中存在的各类对象。</p></blockquote><p>类是一种用于创建具体对象的模版，创建出的对象叫做<strong>实例</strong>。</p><p>由类创建实例是由构造函数完成的，需要将构造函数作为类定义的一部分，且函数名和类名相同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  introduceSelf() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi! I'm <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>constuctor</code>关键字声明构造函数，当我们不需要初始化内容时，可以省略</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>我们注意到老师和学生都是人，具有一定相同的属性和方法，因此我们可以将人定义为一个新类</p><p>在这种情况下，我们称<code>Person</code>类是<code>Professor</code>类和<code>Student</code>类的<strong>超类</strong>或<strong>父类</strong>。反之，为<strong>子类</strong></p><p>当一个方法在不同的类中，拥有相同的函数名，但具体实现不同，我们将这一特性称为<strong>多态</strong>。当一个方法在子类中替换了父类的实现，我们称之为子类<strong>重写</strong>了父类的实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Professor</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  teaches;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(name, teaches) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.teaches = teaches;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  introduceSelf() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">`My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, and I will be your <span class="subst">$&#123;<span class="keyword">this</span>.teaches&#125;</span> professor.`</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  grade(paper) &#123;</span><br><span class="line">    <span class="keyword">const</span> grade = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (<span class="number">5</span> - <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(grade);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><blockquote><p>对象的内部状态保持了私有性，外部代码只能通过对象所提供的接口访问和修改对象的内部状态，不能直接访问和修改对象的内部状态</p></blockquote><p>保持对象内部状态的私有性、明确划分对象的公共接口和内部状态，这一特性称为<strong>封装</strong></p><p>便于方法的更新</p><p>私有属性和私有方法需要以<code>#</code>开头</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  #year;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(name, year) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    this.#year = year;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  introduceSelf() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi! I'm <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, and I'm in year <span class="subst">$&#123;<span class="keyword">this</span>.#year&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  canStudyArchery() &#123;</span><br><span class="line">    return this.#year &gt; 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了私有性后，不能在外部访问，否则会抛出<code>SyntaxError</code></p><h3 id="使用JSON"><a href="#使用JSON" class="headerlink" title="使用JSON"></a>使用JSON</h3><blockquote><p>JavaScript对象表示法（JavaScript Object Notation, JSON），是用于将结构化数据表示为JavaScript对象的标准格式。通常用于在网站上表示和传输数据</p></blockquote><h4 id="什么是JSON？"><a href="#什么是JSON？" class="headerlink" title="什么是JSON？"></a>什么是JSON？</h4><p>JSON是一种按照JavaScript对象语法的数据格式，虽然基于JavaScript，但是独立于JavaScript。JSON可以最为一个对象或字符串存在，前者用于解读JSON属性，后者用于网络传输。JavaScript提供一个全局的可访问的JSON对象来对这两种数据进行转换。</p><blockquote><p>将字符串转为原生对象称为反序列化，反之为序列化</p></blockquote><p><strong>JSON结构</strong></p><p>JSON的格式非常类似于JavaScript对象字面量。可以在JSON中包含与标准JavaScript对象相同的基本数据类型（字符串、数字、数组、布尔值和其他对象字面量），例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"squadName"</span>: <span class="string">"Super hero squad"</span>,</span><br><span class="line">  <span class="attr">"homeTown"</span>: <span class="string">"Metro City"</span>,</span><br><span class="line">  <span class="attr">"formed"</span>: <span class="number">2016</span>,</span><br><span class="line">  <span class="attr">"secretBase"</span>: <span class="string">"Super tower"</span>,</span><br><span class="line">  <span class="attr">"active"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"members"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Molecule Man"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">29</span>,</span><br><span class="line">      <span class="attr">"secretIdentity"</span>: <span class="string">"Dan Jukes"</span>,</span><br><span class="line">      <span class="attr">"powers"</span>: [<span class="string">"Radiation resistance"</span>, <span class="string">"Turning tiny"</span>, <span class="string">"Radiation blast"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Madame Uppercut"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">39</span>,</span><br><span class="line">      <span class="attr">"secretIdentity"</span>: <span class="string">"Jane Wilson"</span>,</span><br><span class="line">      <span class="attr">"powers"</span>: [</span><br><span class="line">        <span class="string">"Million tonne punch"</span>,</span><br><span class="line">        <span class="string">"Damage resistance"</span>,</span><br><span class="line">        <span class="string">"Superhuman reflexes"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Eternal Flame"</span>,</span><br><span class="line">      <span class="attr">"age"</span>: <span class="number">1000000</span>,</span><br><span class="line">      <span class="attr">"secretIdentity"</span>: <span class="string">"Unknown"</span>,</span><br><span class="line">      <span class="attr">"powers"</span>: [</span><br><span class="line">        <span class="string">"Immortality"</span>,</span><br><span class="line">        <span class="string">"Heat Immunity"</span>,</span><br><span class="line">        <span class="string">"Inferno"</span>,</span><br><span class="line">        <span class="string">"Teleportation"</span>,</span><br><span class="line">        <span class="string">"Interdimensional travel"</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将字符串加载到JavaScript程序中，并将其解析到一个名为<code>superHeroes</code>的变量，可以访问其中的数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">superHeroes.hometown;</span><br><span class="line">superHeroes[<span class="string">"active"</span>];</span><br><span class="line">superHeroes[<span class="string">"members"</span>][<span class="number">1</span>][<span class="string">"powers"</span>][<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>JSON数组</strong></p><p>以下也是合法的JSON</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Molecule Man"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="string">"secretIdentity"</span>: <span class="string">"Dan Jukes"</span>,</span><br><span class="line">    <span class="string">"powers"</span>: [<span class="string">"Radiation resistance"</span>, <span class="string">"Turning tiny"</span>, <span class="string">"Radiation blast"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Madame Uppercut"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">39</span>,</span><br><span class="line">    <span class="string">"secretIdentity"</span>: <span class="string">"Jane Wilson"</span>,</span><br><span class="line">    <span class="string">"powers"</span>: [</span><br><span class="line">      <span class="string">"Million tonne punch"</span>,</span><br><span class="line">      <span class="string">"Damage resistance"</span>,</span><br><span class="line">      <span class="string">"Superhuman reflexes"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>:warning:<strong>注意</strong></p><ul><li>JSON是纯数据格式，只包含属性，没有方法</li><li>JSON要求在字符串和属性名周围使用双引号</li><li>JSON中只有带引号的字符串可以用作属性</li></ul><h4 id="对象和文本间的转换"><a href="#对象和文本间的转换" class="headerlink" title="对象和文本间的转换"></a>对象和文本间的转换</h4><p><code>parse()</code>：将文本转换为JavaScript对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">populate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> requestURL =</span><br><span class="line">    <span class="string">"https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json"</span>;</span><br><span class="line">  <span class="keyword">const</span> request = <span class="keyword">new</span> Request(requestURL);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(request);</span><br><span class="line">  <span class="keyword">const</span> superHeroesText = <span class="keyword">await</span> response.text();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> superHeroes = <span class="built_in">JSON</span>.parse(superHeroesText);</span><br><span class="line">  populateHeader(superHeroes);</span><br><span class="line">  populateHeroes(superHeroes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>stringfy()</code>：将对象转换为文本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">name</span>: <span class="string">"Chris"</span>, <span class="attr">age</span>: <span class="number">38</span> &#125;;</span><br><span class="line">myObj;</span><br><span class="line"><span class="keyword">let</span> myString = <span class="built_in">JSON</span>.stringify(myObj);</span><br><span class="line">myString;</span><br></pre></td></tr></table></figure><h2 id="异步JavaScript"><a href="#异步JavaScript" class="headerlink" title="异步JavaScript"></a>异步JavaScript</h2><h3 id="异步JavaScript简介"><a href="#异步JavaScript简介" class="headerlink" title="异步JavaScript简介"></a>异步JavaScript简介</h3><blockquote><p>异步技术使你的程序可以在执行一个可能长期运行的任务的同时，继续对其他事件做出反应而不必等待任务完成</p></blockquote><p>浏览器提供的许多服务可能需要较长耗时，因此需要异步完成，例如：</p><ul><li><code>fetch()</code>，发起HTTP请求</li><li><code>getUserMedia()</code>，访问用户摄像头和麦克风</li><li><code>showOpenFilePicker()</code>，请求用户选择文件以访问</li></ul><h4 id="同步编程"><a href="#同步编程" class="headerlink" title="同步编程"></a>同步编程</h4><p>浏览器按照我们书写代码的顺序一行行执行，在一行结束后才会执行下一行。这是很有必要的，因为每一行代码都是建立在前面代码的基础之上</p><p>当调用函数耗时长时，无法进行后续操作。我们希望能有一种方法：</p><ul><li>通过调用一个函数来启动一个长耗时操作</li><li>让函数开始操作后立即返回，我们的程序可以保持对其他事物做出反应的能力</li><li>当操作完成时，通知结果</li></ul><h4 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h4><p>事件处理程序是异步编程的一种形式，提供的函数（事件处理程序）将在事件发生时（而不是立即）被调用。</p><p>一些早期的异步API就是用这种方式使用事件的。<code>XMLHttpRequest</code> API可以让你用JavaScript</p><p>向远程服务器发起HTTP请求。由于可能耗时久，所以被设计成异步API，可以通过<u>给<code>XMLHttpRequest</code>对象添加事件监听器</u>来让程序再请求进展和最终完成是获得通知：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="built_in">document</span>.querySelector(<span class="string">".event-log"</span>);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#xhr"</span>).addEventListener(<span class="string">"click"</span>, () =&gt; &#123;</span><br><span class="line">  log.textContent = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.addEventListener(<span class="string">"loadend"</span>, () =&gt; &#123;</span><br><span class="line">    log.textContent = <span class="string">`<span class="subst">$&#123;log.textContent&#125;</span>完成！状态码：<span class="subst">$&#123;xhr.status&#125;</span>`</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  xhr.open(</span><br><span class="line">    <span class="string">"GET"</span>,</span><br><span class="line">    <span class="string">"https://raw.githubusercontent.com/mdn/content/main/files/en-us/_wikihistory.json"</span>,</span><br><span class="line">  );</span><br><span class="line">  xhr.send();</span><br><span class="line">  log.textContent = <span class="string">`<span class="subst">$&#123;log.textContent&#125;</span>请求已发起\n`</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#reload"</span>).addEventListener(<span class="string">"click"</span>, () =&gt; &#123;</span><br><span class="line">  log.textContent = <span class="string">""</span>;</span><br><span class="line">  <span class="built_in">document</span>.location.reload();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h4><blockquote><p>回调函数式一个被传递到另一个函数中，会在适当的时候被调用的函数。它曾是JavaScript中实现异步函数的主要方式。</p></blockquote><p>事件处理程序是一种特殊的回调函数</p><p>然而，当回调函数本身需要调用其他包含回调函数的函数时，就会变得复杂。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStep1</span>(<span class="params">init, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = init + <span class="number">1</span>;</span><br><span class="line">  callback(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStep2</span>(<span class="params">init, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = init + <span class="number">2</span>;</span><br><span class="line">  callback(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStep3</span>(<span class="params">init, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = init + <span class="number">3</span>;</span><br><span class="line">  callback(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doOperation</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  doStep1(<span class="number">0</span>, (result1) =&gt; &#123;</span><br><span class="line">    doStep2(result1, (result2) =&gt; &#123;</span><br><span class="line">      doStep3(result2, (result3) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`结果：<span class="subst">$&#123;result3&#125;</span>`</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">doOperation();</span><br></pre></td></tr></table></figure><p>会造成深度嵌套，难以阅读和调试，被称为“回调地狱”。因此，大多数现代异步API不使用回调。事实上，JavaScript中异步编程的基础是<code>Promise</code></p><h3 id="如何使用Promise"><a href="#如何使用Promise" class="headerlink" title="如何使用Promise"></a>如何使用Promise</h3><blockquote><p>Promise是现代JavaScript中异步编程的基础。它是一个由异步函数返回的对象，可以指示操作当前所处的状态。在Promise返回给调用者时，操作往往还没完成，但Promise对象提供了方法来处理操作最终的成功或失败</p></blockquote><h4 id="使用fetch-API"><a href="#使用fetch-API" class="headerlink" title="使用fetch() API"></a>使用fetch() API</h4><p><code>fetch()</code> API是一个现代的、基于Promise的、用于替代<code>XMLHttpRequest</code>的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = fetch(</span><br><span class="line">  <span class="string">"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json"</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fetchPromise);</span><br><span class="line"></span><br><span class="line">fetchPromise.then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`已收到响应：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"已发送请求……"</span>);</span><br></pre></td></tr></table></figure><p>已收到的响应最后显示，<code>fetch()</code>请求仍在进行时就返回了，使程序保持响应性</p><p>将处理程序传到返回的Promise对象的<code>then()</code>方法中</p><h4 id="链式使用Promise"><a href="#链式使用Promise" class="headerlink" title="链式使用Promise"></a>链式使用Promise</h4><p>在这里，我们想获得JSON格式的响应数据，所以调用<code>Reqsponse</code>对象的<code>json()</code>方法。事实上，<code>json()</code>也是异步的，我们连续调用了两个异步函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = fetch(</span><br><span class="line">  <span class="string">"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json"</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">fetchPromise.then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> jsonPromise = response.json();</span><br><span class="line">  jsonPromise.then(<span class="function">(<span class="params">json</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(json[<span class="number">0</span>].name);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise的优雅之处在于<code>then()</code>本身也会返回一个Promise，指示<code>then()</code>中调用异步函数的完成状态，我们将上述代码可以写作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = fetch(</span><br><span class="line">  <span class="string">"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json"</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">fetchPromise</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json())</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data[<span class="number">0</span>].name);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>我们可以直接返回<code>json()</code>返回的Promise，并在它基础上调用第二个<code>then()</code>，这被称为<strong>Promise链</strong></p><h4 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h4><p><code>fetch()</code>API可能因为很多原因抛出错误，我们也会在服务器返回错误消息时抛出一个错误。</p><p>为了支持错误处理，<code>Promise</code>对象提供一个<code>catch()</code>方法：当异步操作成功时，传递给<code>then()</code>，否则传递给<code>catch()</code></p><h4 id="Promise-术语"><a href="#Promise-术语" class="headerlink" title="Promise 术语"></a>Promise 术语</h4><p>首先，Promise有三种状态：</p><ul><li>待定（pending）：初始状态。此时请求还在进行中</li><li>已兑现（fulfilled）：操作成功</li><li>已拒绝（rejected）：操作失败</li></ul><h4 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h4><p><code>async</code>关键字提供了一种更简单的方法处理基于异步Promise的代码，在一个函数的开头添加<code>async</code>，就可以使其成为一个异步函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这是一个异步函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在异步函数中，可以在调用一个返回Promise的函数前，使用<code>await</code>关键字。这会使代码在该点等待，直到Promise被完成。例如，重写我们的fetch示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchProducts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 在这一行之后，我们的函数将等待 `fetch()` 调用完成</span></span><br><span class="line">    <span class="comment">// 调用 `fetch()` 将返回一个“响应”或抛出一个错误</span></span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(</span><br><span class="line">      <span class="string">"https://mdn.github.io/learning-area/javascript/apis/fetching-data/can-store/products.json"</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!response.ok) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`HTTP 请求错误：<span class="subst">$&#123;response.status&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在这一行之后，我们的函数将等待 `response.json()` 的调用完成</span></span><br><span class="line">    <span class="comment">// `response.json()` 调用将返回 JSON 对象或抛出一个错误</span></span><br><span class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> response.json();</span><br><span class="line">    <span class="built_in">console</span>.log(json[<span class="number">0</span>].name);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`无法获取产品列表：<span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetchProducts();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Fontend Notes 2] CSS</title>
      <link href="/2024/06/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2024/06/17/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>本文参考<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS" target="_blank" rel="noopener">MDN 文档 CSS</a></p><h2 id="CSS第一步"><a href="#CSS第一步" class="headerlink" title="CSS第一步"></a>CSS第一步</h2><h3 id="CSS的组成"><a href="#CSS的组成" class="headerlink" title="CSS的组成"></a>CSS的组成</h3><p>将CSS应用于文档的三种方法：</p><ul><li>外部样式表<ul><li>一个.css文件</li></ul></li><li>内部样式表<ul><li>包含在HTML<code>&lt;head&gt;</code>元素中的<code>&lt;style&gt;</code>元素内</li></ul></li><li>内联样式<ul><li>在元素的style属性中定义</li></ul></li></ul><p><strong>优先级</strong></p><ul><li>层叠：为同一个选择器定义了两条规则，后面的样式会替代较早的样式</li><li>优先级：类选择器比元素选择器优先级更高，取消了其他冲突的样式声明</li></ul><p><strong>属性和值</strong></p><p>在最基本的层面上，CSS由两部分组成：</p><ul><li>属性：想更改的样式特征，如font-size, width, color…</li><li>值：每个属性对应一个值</li></ul><p><strong>函数</strong></p><ul><li><code>calc()</code>函数：允许在CSS中进行简单计算</li><li><code>transform</code>函数：另一个例子是tranform的不同取值，如<code>rotate()</code></li></ul><p><strong>@规则</strong></p><p>常见的@规则是<code>@media</code>，用于创建媒体查询。媒体查询使用条件逻辑应用CSS样式，以下例子表示：若浏览器视口宽于30em，则为蓝色背景</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">30em</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>简写属性</strong></p><p>padding, border, margin等属性允许在一行中设置多个属性值，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在像 padding 和 margin 这样的 4 值简写语法中，</span></span><br><span class="line"><span class="comment">   数值的应用顺序是上、右、下、左（从顶部顺时针方向）。</span></span><br><span class="line"><span class="comment">   也有其他的简写类型，例如 2 值简写，</span></span><br><span class="line"><span class="comment">   它为顶部/底部设置 padding/margin，然后是左侧/右侧 */</span></span><br><span class="line"><span class="selector-tag">padding</span>: 10<span class="selector-tag">px</span> 15<span class="selector-tag">px</span> 15<span class="selector-tag">px</span> 5<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><h3 id="CSS如何运行"><a href="#CSS如何运行" class="headerlink" title="CSS如何运行"></a>CSS如何运行</h3><ol><li>浏览器载入HTML文件</li><li>将HTML文件转化成DOM，DOM是文件在计算机内存中的表现形式</li><li>浏览器拉取HTML相关的大部分资源，比如嵌入到页面的图片、视频和CSS样式。JavaScript则会稍后进行处理</li><li>浏览器拉取到CSS后进行解析，根据选择器的不同类型，把他们分到不同的桶。浏览器基于他找到的不同的选择器，将不同的规则应用在对应的DOM节点中（这个中间步骤称为渲染树）</li><li>上述规则应用于渲染树后，渲染树会依照应该出现的结构进行布局</li><li>网页显示在屏幕上（称为着色）</li></ol><p><img src="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/How_CSS_works/rendering.svg" alt="img"></p><p><strong>关于DOM</strong></p><p>一个DOM有一个树形结构，标记语言中的每一个元素、属性以及文字都对应结构树中的一个节点。节点由节点本身和与其他节点的关系定义。有父子节点和兄弟节点。</p><h2 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h2><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p><strong>选择器列表</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>, <span class="selector-class">.special</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型、类和ID选择器"><a href="#类型、类和ID选择器" class="headerlink" title="类型、类和ID选择器"></a>类型、类和ID选择器</h4><p><strong>全局选择器</strong></p><p>用一个 * 代指，选中文档中所有内容</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#unique</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类选择器</strong></p><p>以一个句点（.）开头</p><p><em>指向特定元素的类</em></p><p>例如：高亮一个带有highlight类的<code>&lt;span&gt;</code>，我们使用附加了类的欲选元素的选择器实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">span</span><span class="selector-class">.highlight</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ID选择器</strong></p><p>ID选择器开头为#而非句点，一篇文档中，一个ID只会用到一次</p><p>可以在ID前加上类型选择器，只指向元素和ID都匹配的类</p><h4 id="标签属性选择器"><a href="#标签属性选择器" class="headerlink" title="标签属性选择器"></a>标签属性选择器</h4><p>根据一个元素上的某个标签的属性<strong>是否存在</strong>或<strong>属性值</strong>来选择</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[title]</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href=<span class="string">"http://example.com"</span>]</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h4><p>伪类：样式化一个元素的特定状态，在现有的元素上应用类</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪元素：表现得像往标记文本中加入新的HTML元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特殊的伪元素：::before和::after</p><p>和content属性一同使用，使用CSS将内容插入文档</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"This should show before the other content. "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h4><p><strong>后代选择器</strong></p><p>利用单个空格字符（ ）组合两个选择器，第一个选择器匹配祖先，第二个选择器匹配选择的元素</p><p><strong>子代关系选择器</strong></p><p>利用大于号（&gt;），只会在选择器选中直接子元素时匹配，更远的继承关系则不会匹配（是后代选择器的特殊情况）</p><p>下面的实例用运算符选择了元素的初代子元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.article</span> &gt; <span class="selector-tag">p</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>邻接兄弟</strong></p><p>邻接兄弟选择器（+）用来选中恰好处于同级的旁边元素</p><p>以下例子会选中一级标题后的第一个<code>&lt;p&gt;</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> + <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">padding</span>: .<span class="number">5em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通用兄弟</strong></p><p>使用通用兄弟关系选择器（~），选中一个元素的兄弟关系，即使它们不直接相邻</p><h3 id="层叠、优先级与继承"><a href="#层叠、优先级与继承" class="headerlink" title="层叠、优先级与继承"></a>层叠、优先级与继承</h3><blockquote><p>CSS层叠样式表（Cascading Style Sheets），理解层叠的含义十分关键</p></blockquote><h4 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h4><ul><li>当两条同级别的规则应用到一个元素时，写在后面的就是实际使用的规则</li></ul><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>浏览器根据优先级决定多个规则通过不同选择器加在相同元素时，应使用哪个规则。基本上是衡量选择器具体与否的尺度：</p><ul><li>元素选择器不是很具体，优先级低</li><li>类选择器具体点，优先级高</li></ul><p>优先级高的选择器会被采用，即使排在前面</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>一些设置在父元素上的CSS属性可以被子元素继承</p><p><strong>控制继承</strong></p><ul><li>inherit：开启继承</li><li>initial：元素属性值设为初始</li><li>revert：重置为浏览器默认样式</li><li>revert-layer：重置为在上一个层叠层建立的值</li><li>unset：重置为自然置，如果属性是自然继承那么就是inherit，否则是initial</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><strong>! important</strong></p><p>覆盖所有普通规则的层叠</p><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><h4 id="区块盒子与行内盒子"><a href="#区块盒子与行内盒子" class="headerlink" title="区块盒子与行内盒子"></a>区块盒子与行内盒子</h4><p>CSS中，盒子的类型一般分为区块盒子（block boxes）和行内盒子（inline boxes）</p><p>类型：盒子在页面流中的行为方式以及与页面上其他盒子的关系，包括内部显示和外部显示</p><h4 id="外部显示类型"><a href="#外部显示类型" class="headerlink" title="外部显示类型"></a>外部显示类型</h4><p><strong>block外部显示</strong>类型的盒子，例如<code>&lt;h1&gt;</code>和<code>&lt;p&gt;</code>，拥有以下特性：</p><ul><li>盒子换行</li><li>width和height生效</li><li>内边距、外边距和边框，会将其他元素从当前盒子周围推开</li><li>若未指定width，方框将研行向扩展，以填充容器内的可用空间</li></ul><p><strong>inline外部显示</strong>类型的盒子，例如<code>&lt;a&gt;</code>和<code>&lt;span&gt;</code>，拥有以下特性：</p><ul><li>盒子不会换行</li><li>width和height不生效</li><li>垂直方向，内边距、外边距和边框，不会将其他处于inline状态的盒子推开</li><li>水平方向，内边距、外边距和边框，会将其他处于inline状态的盒子推开</li></ul><h4 id="内部显示类型"><a href="#内部显示类型" class="headerlink" title="内部显示类型"></a>内部显示类型</h4><p>决定了盒子内部元素的布局方式。</p><p>例如，可以通过设置 <code>display: flex;</code> 来更改内部显示类型。该元素仍将使用外部显示类型 <code>block</code> 但内部显示类型将变为 <code>flex</code>。该方框的任何直接子代都将成为弹性（flex）项。</p><p><strong>不同显示类型的例子</strong></p><p>要在显示模式之间切换，可以将：</p><ul><li><code>display: inline</code> 更改为 <code>display: block</code><ul><li>inline：内联元素</li><li>block：块级元素</li></ul></li><li><code>display: inline-flex</code> 更改为 <code>display: flex</code><ul><li>inline-flex：父元素宽度是子元素宽度之和，被子元素撑开</li><li>flex：父元素宽度100%</li></ul></li><li>特殊：<code>display: inline-block</code><ul><li>不希望换行，但希望宽高生效</li></ul></li></ul><p><img src="box-model.png" alt="box-model"></p><p><strong>标准盒模型与替代盒模型</strong></p><ul><li>默认为标准盒模型<ul><li>width和height定义content的大小</li><li>盒所占的总大小包括width/height+ padding + border</li></ul></li><li>替代盒模型，可通过<code>box-sizing: border-box</code>设置<ul><li>width和height定义的是可见框的大小</li><li>盒所占的总大小包括width/height</li></ul></li></ul><h4 id="外边距、内边距和边框"><a href="#外边距、内边距和边框" class="headerlink" title="外边距、内边距和边框"></a>外边距、内边距和边框</h4><p><strong>外边距折叠</strong></p><p>对于两个外边距相接触的元素，其实际间隔计算方式：</p><ul><li>两个正外边距，结果为较大值</li><li>连个负外边距，结果为较小值</li><li>一正一负，结果为正减负</li></ul><h3 id="背景与边框"><a href="#背景与边框" class="headerlink" title="背景与边框"></a>背景与边框</h3><h4 id="CSS的背景样式"><a href="#CSS的背景样式" class="headerlink" title="CSS的背景样式"></a>CSS的背景样式</h4><p><strong>背景颜色</strong></p><p><code>background-color</code>接受任何可用的颜色值</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#467995</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">255</span> <span class="number">255</span> <span class="number">255</span> / <span class="number">100%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>背景图像</strong></p><p><code>background-img</code>可以在背景中显示图像</p><ul><li>大图不会缩小以适应盒子，可能只能看见一角</li><li>小图会平铺以填充方框</li></ul><p>若还指定了背景颜色，则图片会显示在上层</p><p><strong>控制平铺行为</strong></p><p><code>background-repeat</code>可控制平铺行为：</p><ul><li><code>no-repeat</code>：阻止重复平铺</li><li><code>repeat-x</code>：仅水平方向平铺</li><li><code>repeat-y</code>：仅垂直方向平铺</li><li><code>repeat</code>：默认值，水平和垂直方向均平铺</li></ul><p><strong>调整背景图像大小</strong></p><p><code>background-size</code>属性，设置长度或百分比</p><ul><li><p>特定的数值：压缩图片至设置的大小，展示全部图像</p></li><li><p><code>cover</code>：保持图像原长宽比，图像部分区域可能跳出盒子</p></li><li><code>contain</code>：调整图像至适合框内的尺寸，若图像和盒子的长宽比不同，可能在上下/左右出现空隙</li></ul><p><strong>背景图像定位</strong></p><p><code>background-position</code>属性，使用坐标系统，方框左上角是(0, 0)。可能的取值包括：</p><ul><li>top, right等关键字</li><li>长度和百分比值，如：20px, 10%</li></ul><p><strong>渐变背景</strong></p><p><code>linear-gradient(deg, color1, color2)</code></p><h4 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h4><ul><li><code>border</code>：同时设置四条边</li><li><code>border-top</code>：只设置一条边</li></ul><p><strong>圆角</strong></p><p><code>border-radius</code>属性，可以用两个字分别表示水平和垂直半径，一般情况下只使用一个值，表示半径</p><h3 id="不同方向的文本"><a href="#不同方向的文本" class="headerlink" title="不同方向的文本"></a>不同方向的文本</h3><h4 id="书写模式"><a href="#书写模式" class="headerlink" title="书写模式"></a>书写模式</h4><p>指文本纵向或横向排列，可以<code>writing-mode</code>属性切换</p><ul><li><code>horizontal-tb</code>：块流向从上至下，文本横向</li><li><code>vertical-rl</code>：块流向从左向右，文本纵向</li><li><code>vertical-lr</code>：块流向从右向左，文本纵向</li></ul><h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p>盒子承载太多东西时，会发生溢出</p><p><strong>CSS尽力减少数据损失</strong></p><p>因此在盒子内容不够时，数据会溢出，从而完整地显示出来</p><p><strong>overflow属性</strong></p><ul><li>控制元素溢出，默认值为<code>visible</code></li><li>若想在内容溢出时裁剪掉，可以在盒子上设置<code>overflow: hidden</code></li><li>在内容溢出时添加滚动条：<code>overflow: scroll</code>，可以x, y轴分开处理</li></ul><h3 id="CSS的值和单位"><a href="#CSS的值和单位" class="headerlink" title="CSS的值和单位"></a>CSS的值和单位</h3><h4 id="数字、长度和百分比"><a href="#数字、长度和百分比" class="headerlink" title="数字、长度和百分比"></a>数字、长度和百分比</h4><p>CSS主要有以下数值数据类型：</p><ul><li><interger>：整数</li><li><number>：整数或小数</li><li><dimension>：在<number>的基础上，有一个附加单位，例如45deg，10px等</li><li><percentage>：百分比值</li></ul><p><strong>长度</strong></p><ul><li>绝对长度<ul><li>cm, mm, in(英寸), pc(派卡), pt(点), px(像素)</li></ul></li><li>相对长度<ul><li>em, rem分别相对父元素和根元素的<strong>字体大小</strong></li><li>vh, vw分别相对于视口的高度和宽度</li><li>百分比是相对父元素</li></ul></li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li><code>cal()</code>可以计算编写时无法定义的值，如<code>cal(20% + 10px)</code></li><li><code>url()</code></li><li>…</li></ul><h3 id="在CSS中调整大小"><a href="#在CSS中调整大小" class="headerlink" title="在CSS中调整大小"></a>在CSS中调整大小</h3><h4 id="原始尺寸"><a href="#原始尺寸" class="headerlink" title="原始尺寸"></a>原始尺寸</h4><p>空的<code>&lt;div&gt;</code>是没有尺寸的</p><h4 id="外部尺寸"><a href="#外部尺寸" class="headerlink" title="外部尺寸"></a>外部尺寸</h4><p>给元素指定尺寸，称为外部尺寸</p><p><strong>百分比</strong></p><p>使用百分比作为margin或padding的单位时，值是以包含块的内联尺寸计算的，也就是元素的水平宽度</p><h4 id="min-和max-尺寸"><a href="#min-和max-尺寸" class="headerlink" title="min-和max-尺寸"></a>min-和max-尺寸</h4><p>可以给元素设定最大或最小尺寸，如<code>min-height</code>设置最小高度</p><p>设置尺寸为百分比，可以使图片可响应，根据页面大小调整</p><h4 id="视口单位"><a href="#视口单位" class="headerlink" title="视口单位"></a>视口单位</h4><p><code>1vh</code>等于视口高度的1%</p><h3 id="图像、媒体和表单元素"><a href="#图像、媒体和表单元素" class="headerlink" title="图像、媒体和表单元素"></a>图像、媒体和表单元素</h3><h4 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h4><p>图像和视频被称为<strong>替换元素</strong>，因为CSS不能影响他们内部布局</p><h4 id="调整图像大小"><a href="#调整图像大小" class="headerlink" title="调整图像大小"></a>调整图像大小</h4><p><code>object-fit</code>属性，替换元素可以以多种方式被调整到合乎盒子的大小：</p><ul><li>cover：图像比例不变，缩小至一边恰好是盒子长度，无空白</li><li>contain：图像比例不变，缩小至全图包裹在盒子中，有空白</li><li>fill：图像比例改变，恰好填满盒子</li></ul><h2 id="CSS排版"><a href="#CSS排版" class="headerlink" title="CSS排版"></a>CSS排版</h2><h3 id="介绍CSS布局"><a href="#介绍CSS布局" class="headerlink" title="介绍CSS布局"></a>介绍CSS布局</h3><h4 id="正常布局流"><a href="#正常布局流" class="headerlink" title="正常布局流"></a>正常布局流</h4><p>即浏览器默认的HTML布局方式</p><p>下列布局技术会覆盖默认的布局行为：</p><ul><li><code>display</code>属性：如之前提到的<code>block</code>，<code>inline</code>或<code>inline-block</code>，以及<code>CSS Grid</code>和<code>Flexbox</code></li><li>浮动：应用<code>float</code>值，诸如<code>left</code>可以让块级元素排成一行</li><li><code>position</code>属性：允许精确设置盒子中盒子的位置</li><li>表格布局</li><li>多列布局</li></ul><h4 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a><code>display</code>属性</h4><p>这是css中实现页面布局的主要方法。</p><p><strong>弹性盒子</strong></p><p>Flexbox是CSS弹性盒子布局模块（Flexible Box Layout Module）的缩写，专门进行横向或纵向的一维页面布局。要使用flexbox布局，只需在<strong>父元素</strong>上应用<code>display: flex</code>，<strong>所有子元素</strong>将会进行flex布局</p><p><u>设置flex属性</u></p><p>flex项上还可以应用很多属性，改变flex项在布局中宽/高的方式。</p><p>例如，通过以下方式，会使所有子元素都伸展并填充容器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a>Grid布局</h4><p>Flexbox用于设计横向或纵向的布局，而Grid用于同时在两个维度上把元素按行和列排列整齐</p><p><strong>设置<code>display: grid</code></strong></p><p>还可使用<code>grid-template-rows</code>和<code>grid-template-columns</code>属性定义一些行和列的轨道，例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述css定义了三个1fr的列和两个100px的行</p><p><strong>在网格内放置元素</strong></p><p>除了上述自动排列，我们也可以指定将元素放在里面。利用<code>grid-column</code>和<code>grid-row</code>属性指定每个子元素应该从哪行/列开始，以及在哪行/列结束，这样可以让在元素在多个行/列上展开</p><h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><p>把一个元素设置为<code>float</code>会改变<strong>元素本身</strong>和在正常布局流中<strong>跟随它的其他元素</strong>的行为，该属性可能取值为：</p><ul><li><code>left</code>：将元素浮动到左侧</li><li><code>right</code>：将元素浮动到右侧</li><li><code>none</code>：不浮动，默认值</li><li><code>inherit</code>：继承父元素的浮动属性</li></ul><p>例如，以下css会将box浮动到左侧，并把周围文字推开</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定位技术"><a href="#定位技术" class="headerlink" title="定位技术"></a>定位技术</h4><p>定位技术能把一个元素从原本在正常布局流中应该在的位置，移动到另一个位置。它不是用于页面布局的主要方式，而是管理和微调页面中一个特殊项的方法。依赖于<code>position</code>属性，主要的定位类型有：</p><ul><li>静态定位<code>static</code>：<strong>默认</strong>属性</li><li>相对定位<code>relative</code>：允许我们<strong>相对于元素的位置</strong>进行移动，例如将两个元素叠放在页面</li><li>绝对定位<code>absolute</code>：将元素完全移出，可以相对于<html>元素或该元素<strong>最近被定位祖先元素</strong>固定。例如通过标签显示盒隐藏的内容面板，以及通过按钮控制滑动到屏幕中的信息面板</li><li>固定定位<code>fixed</code>：与绝对定位相似，但它是将元素相对于<strong>浏览器视口</strong>固定，而不是另一个元素。例如固定导航栏</li><li>粘性定位<code>sticky</code>：先让元素保持和static一样的定位，当相对视口位置达到某个预设值时，像fixed一样定位</li></ul><p><strong>注意：</strong>相对定位的元素在文档布局流中会预留位置，而绝对定位不会</p><p><strong>包含块</strong></p><p>如何确定包含块：</p><ul><li>如果元素是<code>static</code>、<code>relative</code>、<code>sticky</code>，包含块是最近的祖先元素</li><li>如果元素是<code>abusolute</code>，包含块是最近的非<code>static</code>的祖先元素</li><li>如果元素是<code>fixed</code>，包含块是视口</li></ul><p><strong>z-index</strong></p><p>用于决定元素的重叠关系，是对z轴的参考。默认值为0，值越大越上层</p><h3 id="star-响应式设计"><a href="#star-响应式设计" class="headerlink" title=":star:响应式设计"></a>:star:响应式设计</h3><p>普通情况下，页面只适配特定的屏幕大小。随着人们使用的屏幕尺寸种类增加，出现了响应式网页设计的概念（responsive web design, RWD）</p><p>现代布局方式，例如多栏布局、伸缩盒和网格默认是响应式的。</p><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>媒体查询使得仅在浏览器和设备的环境与指定的规则相匹配的时候CSS才会被应用，例如“视口宽于480px”。媒体查询是响应式设计的关键部分，允许按照视口尺寸创建不同的布局，也可以用来探测与站点运行环境相关联的其他条件，如用户使用鼠标还是触摸屏。</p><h4 id="媒体查询基础"><a href="#媒体查询基础" class="headerlink" title="媒体查询基础"></a>媒体查询基础</h4><p>基础语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> media-type <span class="keyword">and</span> (media-feature-rule) &#123;</span><br><span class="line"><span class="comment">/*css rules go here*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个媒体类型，告诉浏览器这段代码用在什么类型媒体上</li><li>一个媒体特征规则，CSS生效所需的规则</li><li>一组CSS规则，会在媒体类型正确的时候应用</li></ul><p><strong>媒体类型</strong></p><p>可以指定媒体类型为：</p><ul><li>all</li><li>print</li><li>screen</li><li>speech</li></ul><p>例如，以下代码会在页面被打印是把body设定为12pt大小</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> print &#123;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">12pt</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>媒体特征规则</strong></p><ul><li>宽和高<ul><li>width, max-width, height…</li></ul></li><li>朝向<ul><li><code>orientation</code>属性：竖放（portrait）和横放（landscape）</li></ul></li><li>指点设备<ul><li><code>hover</code>属性</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Fontend Notes 1] HTML</title>
      <link href="/2024/06/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80-HTML/"/>
      <url>/2024/06/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80-HTML/</url>
      
        <content type="html"><![CDATA[<p>本文参考<a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML" target="_blank" rel="noopener">MDN 文档 HTML部分</a><br>HTML（Hypertext Markup Language）是由不同<u>元素</u>组成的标记语言。可应用于文本片段，使其具有不同含义，将文档结构化为逻辑块，并且可以将图片，影像等内容嵌入到页面中。</p><blockquote><p>XML: Extensible Markup Language</p></blockquote><h2 id="HTML介绍"><a href="#HTML介绍" class="headerlink" title="HTML介绍"></a>HTML介绍</h2><h3 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h3><p>由开始标签、内容和结束标签组成，例如<p>hello</p></p><ul><li>嵌套元素</li><li>块级元素和内联元素<ul><li>块级元素：以块的形式展现，与前后内容均不在一行上。块级元素不会嵌套在内联元素中，但可能嵌套在另一个块级元素中。例如<code>&lt;p&gt;</code></li><li>内联元素（行级元素）：通常出现在块级元素中，并环绕文档内容的一小部分。不会导致文本换行。例如<code>&lt;em&gt;</code></li></ul></li><li>空元素<ul><li>只有一个标签，通常用于插入一下东西，例如<code>&lt;img&gt;</code></li></ul></li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>元素可以拥有属性，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"editor-note"</span>&gt;</span>My cat is very grumpy<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性必须包含：空格、属性名、属性值</p><ul><li>布尔属性<ul><li>没有值的属性，如<code>disabled</code></li></ul></li></ul><h3 id="剖析HTML文档"><a href="#剖析HTML文档" class="headerlink" title="剖析HTML文档"></a>剖析HTML文档</h3><h4 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span> <span class="comment">&lt;!--声明文档类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span> <span class="comment">&lt;!--根元素--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span> <span class="comment">&lt;!--不显示--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span> <span class="comment">&lt;!--元数据--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的测试站点<span class="tag">&lt;/<span class="name">title</span>&gt;</span> <span class="comment">&lt;!--页面标题--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="comment">&lt;!--显示内容--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是我的页面<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTML中的空白"><a href="#HTML中的空白" class="headerlink" title="HTML中的空白"></a>HTML中的空白</h4><p>HTML解释器会将连续出现的空白字符（空格与换行）减少为一个单独的空格符。</p><h4 id="HTML中的特殊字符"><a href="#HTML中的特殊字符" class="headerlink" title="HTML中的特殊字符"></a>HTML中的特殊字符</h4><div class="table-container"><table><thead><tr><th>原义字符</th><th>等价字符</th></tr></thead><tbody><tr><td>&lt;</td><td>&amp; lt ;</td></tr><tr><td>&gt;</td><td>&amp; gt ;</td></tr><tr><td>“</td><td>&amp; quot ;</td></tr><tr><td>‘</td><td>&amp; apos ;</td></tr><tr><td>&amp;</td><td>&amp; amp ;</td></tr></tbody></table></div><h3 id="HTML头部"><a href="#HTML头部" class="headerlink" title="HTML头部"></a>HTML头部</h3><h4 id="添加标题"><a href="#添加标题" class="headerlink" title="添加标题"></a>添加标题</h4><p><code>&lt;title&gt;</code>元素 </p><h4 id="元数据：-lt-meta-gt-元素"><a href="#元数据：-lt-meta-gt-元素" class="headerlink" title="元数据：&lt;meta&gt;元素"></a>元数据：<code>&lt;meta&gt;</code>元素</h4><p>元数据就是描述数据的数据。</p><p><strong>指定文档中的字符编码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>utf-8</code>是一个通用字符集</p></blockquote><p><strong>添加作者和描述</strong></p><ul><li><code>name</code>指定<code>meta</code>元素的类型</li><li><code>content</code>指定实际的元数据内容</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"Chris Mills"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">"description"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">"The MDN Web Docs Learning Area aims to provide</span></span></span><br><span class="line"><span class="tag"><span class="string">complete beginners to the Web with all they need to know to get</span></span></span><br><span class="line"><span class="tag"><span class="string">started with developing web sites and applications."</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="在HTML中应用CSS和JavaScript"><a href="#在HTML中应用CSS和JavaScript" class="headerlink" title="在HTML中应用CSS和JavaScript"></a>在HTML中应用CSS和JavaScript</h4><p>分别使用<code>&lt;link&gt;</code>元素和<code>&lt;script&gt;</code>元素</p><ul><li><code>&lt;link&gt;</code>元素包含两个属性，<code>rel=&quot;stylesheet&quot;</code>表示这是文档样式表，<code>href</code>包含样式表文件的路径。是空元素</li><li><code>script</code>元素包含<code>src</code>属性，指向要加载的JavaScript文件路径。<ul><li>最好加上<code>defer</code>以告诉浏览器在解析完成HTML后再加载JavaScript，避免JavaScript试图访问页面上不存在的HTML元素而产生错误</li></ul></li></ul><h4 id="为文档设定主语言"><a href="#为文档设定主语言" class="headerlink" title="为文档设定主语言"></a>为文档设定主语言</h4><p>可以通过在<code>&lt;html&gt;</code>标签中添加<code>lang</code>属性，为站点设定主语言</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line">  …</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HTML文本处理基础"><a href="#HTML文本处理基础" class="headerlink" title="HTML文本处理基础"></a>HTML文本处理基础</h3><p>HTML如何通过添加标题和段落、强调单词、创建列表等方式构造文本</p><h4 id="标题和段落"><a href="#标题和段落" class="headerlink" title="标题和段落"></a>标题和段落</h4><p>段落：<code>&lt;p&gt;</code></p><p>标题：<code>&lt;h1&gt;, &lt;h2&gt;...</code></p><ul><li><p>建议不超过三层标题</p></li><li><p>不仅是样式区别，更重要的提供了语义信息</p></li></ul><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul><li>无序列表：<ul><li>从<code>&lt;ul&gt;</code>元素开始，包裹清单上所有被列出的项目</li><li>使用<code>&lt;li&gt;</code>元素，包裹列出的每个项目</li></ul></li><li>有序列表<ul><li>使用<code>&lt;ol&gt;</code>元素</li></ul></li><li>嵌套列表</li></ul><h4 id="重点强调"><a href="#重点强调" class="headerlink" title="重点强调"></a>重点强调</h4><p><strong>语义区分</strong></p><ul><li>倾斜：<code>&lt;em&gt;</code>(emphasis)</li><li>加粗：<code>&lt;strong&gt;</code></li></ul><p><strong>单纯样式</strong></p><blockquote><p>这样仅仅影响表象而没有语义的元素，称为表象元素。语义对无障碍、SEO（搜索引擎优化）等非常重要</p></blockquote><ul><li><code>&lt;i&gt;</code>：斜体</li><li><code>&lt;b&gt;</code>：粗体</li><li><code>&lt;u&gt;</code>：下划线</li></ul><h3 id="创建超链接"><a href="#创建超链接" class="headerlink" title="创建超链接"></a>创建超链接</h3><p>将文本或其他内容包裹在<code>&lt;a&gt;</code>元素内，并给它一个包含网址的<code>href</code>属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  我创建了一个指向</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.mozilla.org/zh-CN/"</span>&gt;</span>Mozilla 主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span>的链接。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>块级链接、图片链接</strong></p><p>任何内容都可以作为链接出现，只需将其包裹在锚点元素内</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://developer.mozilla.org/zh-CN/"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>MDN Web 文档<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>自从 2005 年起，就开始记载包括 CSS、HTML、JavaScript 等网络技术。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>使用title属性添加支持信息</strong></p><p>当鼠标悬停时，标题作为提示信息出现</p><h4 id="统一资源定位符（URL）与路径（path）"><a href="#统一资源定位符（URL）与路径（path）" class="headerlink" title="统一资源定位符（URL）与路径（path）"></a>统一资源定位符（URL）与路径（path）</h4><p>统一资源定位符（Uniform Resource Locator）是一个定义了在网络上的位置的文本字符串。</p><p>可使用路径查找文件</p><p><strong>文档片段</strong></p><p>超链接除了可以链接到文档外，也可以链接到HTML文档的特定部分。</p><ul><li><p>先给要链接到的元素分配一个id属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"Mailing_address"</span>&gt;</span>邮寄地址<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>将id放在URL的末尾，并在前加#</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--其他文档--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  要提供意见和建议，请将信件邮寄至<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"contacts.html#Mailing_address"</span></span></span><br><span class="line"><span class="tag">    &gt;</span>我们的地址<span class="tag">&lt;/<span class="name">a</span></span></span><br><span class="line"><span class="tag">  &gt;</span>。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--同一文档--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>本页面底部可以找到<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#Mailing_address"</span>&gt;</span>公司邮寄地址<span class="tag">&lt;/<span class="name">a</span>&gt;</span>。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>在下载链接时使用download属性</strong></p><p>除了浏览器中打开外，链接还可以提供下载功能</p><p>使用download属性调用下载功能，并提供一个默认的保存文件名</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">"https://download.mozilla.org/?product=firefox-latest-ssl&amp;os=win64&amp;lang=zh-CN"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">download</span>=<span class="string">"firefox-latest-64bit-installer.exe"</span>&gt;</span></span><br><span class="line">  下载最新的 Firefox 中文版 - Windows（64 位）</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文档与网站构建"><a href="#文档与网站构建" class="headerlink" title="文档与网站构建"></a>文档与网站构建</h3><p>HTML可以使用块级元素定义网站中的复合区域</p><h4 id="文档的基本组成部分"><a href="#文档的基本组成部分" class="headerlink" title="文档的基本组成部分"></a>文档的基本组成部分</h4><ul><li><code>&lt;header&gt;</code>: 页眉</li><li><code>&lt;nav&gt;</code>: 导航栏</li><li><code>&lt;main&gt;</code>: 主内容<ul><li>其中可以有各种内容区段，可用<code>&lt;article&gt;</code>、<code>&lt;section&gt;</code>和<code>&lt;div&gt;</code>等元素表示</li></ul></li><li><code>&lt;aside&gt;</code>: 侧边栏<ul><li>经常嵌套在<code>&lt;main&gt;</code>中</li></ul></li><li><code>&lt;footer&gt;</code>: 页脚</li></ul><h4 id="HTML布局元素细节"><a href="#HTML布局元素细节" class="headerlink" title="HTML布局元素细节"></a>HTML布局元素细节</h4><p><strong>无语义元素</strong></p><p><code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>元素</p><ul><li><code>&lt;span&gt;</code>是一个内联的（inline）无语义元素</li><li><code>&lt;div&gt;</code>是一个块级无语义元素</li></ul><p><strong>换行与水平分割线</strong></p><p>均是空元素</p><ul><li><code>&lt;br&gt;</code>：换行元素</li><li><code>&lt;hr&gt;</code>：主题性中断元素</li></ul><h2 id="多媒体与嵌入"><a href="#多媒体与嵌入" class="headerlink" title="多媒体与嵌入"></a>多媒体与嵌入</h2><h3 id="HTML中的图片"><a href="#HTML中的图片" class="headerlink" title="HTML中的图片"></a>HTML中的图片</h3><p><code>&lt;img&gt;</code>元素：</p><ul><li><code>src</code>属性：图片的URL</li><li><code>alt</code>属性：备选文本</li><li><code>width</code>和<code>height</code>属性：指定图片宽度和高度，以像素为单位<ul><li>好处：预留空间，不会产生页面文字移动</li></ul></li><li><code>title</code>属性：悬停提示</li></ul><h4 id="为图片搭配说明文字"><a href="#为图片搭配说明文字" class="headerlink" title="为图片搭配说明文字"></a>为图片搭配说明文字</h4><ul><li><code>&lt;figure&gt;</code>元素：包裹图片和说明文字</li><li><code>&lt;figcaption&gt;</code>元素：说明文字</li></ul><h4 id="网页上的其他图形"><a href="#网页上的其他图形" class="headerlink" title="网页上的其他图形"></a>网页上的其他图形</h4><ul><li>Canvas<ul><li><code>&lt;canvas&gt;</code>元素提供了使用JavaScript绘制2D图像的API</li></ul></li><li>SVG<ul><li>借助可缩放矢量图形来渲染2D图形</li></ul></li><li>使用HTML音频和视频<ul><li>与<code>&lt;img&gt;</code>类似，可以使用<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>嵌入网页，并控制播放</li></ul></li></ul><h3 id="视频和音频内容"><a href="#视频和音频内容" class="headerlink" title="视频和音频内容"></a>视频和音频内容</h3><p><strong><code>vedio</code>元素</strong></p><p>嵌入视频，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"rabbit320.webm"</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    你的浏览器不支持 HTML 视频。可点击<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"rabbit320.mp4"</span>&gt;</span>此链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span>观看。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>src</code>：视频资源的来源</li><li><code>controls</code>：让视频或音频包含浏览器自带的控制界面</li><li><code>video</code>元素内的段落：后背内容</li><li>其他特性：<ul><li><code>width</code>和<code>height</code></li><li><code>autoplay</code>：立即播放</li><li><code>loop</code>：自动重播</li><li><code>poster</code>：指向图像URL，会在视频播放前显示</li><li><code>preload</code>：缓冲</li></ul></li></ul><p><strong><code>&lt;audio&gt;</code>元素</strong></p><p>与<code>video</code>元素几乎完全相同，只有细微差别</p><ul><li>不支持<code>height</code>和<code>width</code>属性</li><li>不支持<code>poster</code>属性</li></ul><h2 id="HTML表格"><a href="#HTML表格" class="headerlink" title="HTML表格"></a>HTML表格</h2><p>使用表格是很糟糕的，原因是：</p><ul><li>减少了视觉受损用户的无障碍</li><li>产生很多标签</li><li>不能自动响应</li></ul><p><strong>创建表格</strong></p><ul><li><code>&lt;table&gt;</code>：最外层，包裹内容</li><li><code>&lt;tr&gt;</code>：表格一行</li><li><code>&lt;td&gt;</code>：单元格</li><li><code>&lt;th&gt;</code>：表格标题</li></ul><p><strong>允许单元格跨越多行和列</strong></p><p>使用<code>colspan</code>和<code>rowspan</code>属性，控制宽度或高度是几个单元格</p><p><strong>为表格中的列提供共同样式</strong></p><p><code>col</code>和<code>colgroup</code>元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">colgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">col</span> <span class="attr">style</span>=<span class="string">"background-color: yellow"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Data 1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Data 2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Calcutta<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Robots<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Jazz<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>表格标题</strong></p><p>在<code>&lt;table&gt;</code>内使用<code>&lt;caption&gt;</code>元素</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习路线</title>
      <link href="/2024/06/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2024/06/15/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>一份前端学习路线，希望能引导未来的方向。Just do it!</p><blockquote><p>本文搬运自：<a href="https://yuyuanweb.feishu.cn/wiki/Abldw5WkjidySxkKxU2cQdAtnah" target="_blank" rel="noopener">程序员鱼皮</a></p><p>本站地址：<a href="https://codefather.cn" target="_blank" rel="noopener">https://codefather.cn</a></p></blockquote><p>💂 + 💻 = 👴🏽</p><p>建议先观看视频导读：<a href="https://www.bilibili.com/video/BV1nh411e7oG/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1nh411e7oG/</a></p><h2 id="路线特点"><a href="#路线特点" class="headerlink" title="路线特点"></a>路线特点</h2><ol><li>一份全面的前端知识点大梳理和汇总</li><li>分阶段学习，每个阶段给出学习目标</li><li>使用符号对知识点的重要程度做了区分，按需学习</li><li>知识点附有描述和资源链接</li><li>提供一份清晰的个人顺序学习路线方法</li><li>提供大量优质学习资源</li></ol><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>可根据知识点前的符号按需选学，并获取知识点描述和学习资源。</p><ul><li>⭐️ 必学（追求速成） </li><li>✅ 建议学（重要知识） </li><li>❗ 面试重点 </li><li>❌ 一般没必要学习 </li><li>💬 描述 </li><li>📚 资源 </li><li>🎯 目标 </li></ul><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ol><li>前言 - 学编程需要的特质</li><li>前端学习七阶段 <ol><li>前端入门</li><li>巩固基础</li><li>前端工程化</li><li>前端优化</li><li>前端生态</li><li>前端求职</li><li>前端未来</li></ol></li><li>我的前端学习路线</li><li>尾声 - 持续学习</li></ol><h2 id="前言-学编程需要的特质"><a href="#前言-学编程需要的特质" class="headerlink" title="前言 - 学编程需要的特质"></a>前言 - 学编程需要的特质</h2><p>相信自己有能力，那么你就真的会有！</p><ul><li>兴趣</li><li>坚持</li><li>付出</li><li>心态</li></ul><h2 id="一、前端入门"><a href="#一、前端入门" class="headerlink" title="一、前端入门"></a>一、前端入门</h2><ul><li>💬 描述：学习前端基础三件套，建议从实战开始，边学边练，培养兴趣，快速入门。 </li><li>📚 资源 <ul><li>freeCodecamp 在线编程：<a href="https://www.freecodecamp.org/" target="_blank" rel="noopener">https://www.freecodecamp.org/</a></li><li>阿里云前端实战学习：<a href="https://edu.aliyun.com/roadmap/frontend" target="_blank" rel="noopener">https://edu.aliyun.com/roadmap/frontend</a></li><li>W3Cschool 编程入门实战：<a href="https://www.w3cschool.cn/codecamp/" target="_blank" rel="noopener">https://www.w3cschool.cn/codecamp/</a></li><li>pink老师前端入门教程：<a href="https://www.bilibili.com/video/BV14J4114768" target="_blank" rel="noopener">https://www.bilibili.com/video/BV14J4114768</a></li></ul></li><li>🎯 目标：了解和实践各语言的基础语法，并能使用开发工具来独立开发一个留言板网站。 </li></ul><h3 id="⭐️-开发工具"><a href="#⭐️-开发工具" class="headerlink" title="⭐️ 开发工具"></a>⭐️ 开发工具</h3><ul><li>💬 描述：工欲善其事，必先利其器。</li></ul><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><ul><li>⭐️ Chrome</li><li>✅ Edge</li><li>✅ Firefox</li><li>❌ Opera</li><li>Safari</li></ul><h4 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h4><ul><li>⭐️ VSCode</li><li>✅ WebStorm</li><li>Atom</li><li>⭐️ Sublime Text</li><li>HBuilder X</li><li>记事本</li><li>在线 IDE</li></ul><h4 id="文档笔记"><a href="#文档笔记" class="headerlink" title="文档笔记"></a>文档笔记</h4><ul><li>✅ Markdown 语法</li><li>✅ Typora</li><li>在线笔记 <ul><li>语雀</li><li>腾讯文档</li><li>石墨文档</li><li>印象笔记</li></ul></li><li>Mdnice</li></ul><h3 id="⭐️-HTML"><a href="#⭐️-HTML" class="headerlink" title="⭐️ HTML"></a>⭐️ HTML</h3><ul><li>💬 描述：用于定义一个网页结构的基本技术。 </li><li>📚 资源：<a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/HTML</a> </li><li>⭐️ 基本语法 </li><li>⭐️ 标签 <ul><li>分区 div</li><li>标题 h1 ~ h6</li><li>段落 p</li><li>图像 img</li><li>列表 ul / ol</li><li>超链接 a</li><li>表单 form</li><li>表格 table</li><li>框架 iframe</li></ul></li><li>⭐️ 属性 </li><li>✅ HTML5 特性 <ul><li>语义化标签</li><li>浏览器支持</li><li>多媒体标签</li><li>Canvas 画布</li><li>❌ 内联 SVG</li><li>本地存储 <ul><li>localStorage</li><li>sessionStorage</li><li>❌ Web SQL</li></ul></li><li>Web Workers</li><li>应用缓存（Cache Manifest）</li><li>无障碍</li></ul></li></ul><h3 id="⭐️-CSS"><a href="#⭐️-CSS" class="headerlink" title="⭐️ CSS"></a>⭐️ CSS</h3><ul><li>💬 描述：层叠样式表，用于设计风格和布局。 </li><li>📚 资源：<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/CSS</a> </li><li>⭐️ 基本语法 </li><li>⭐️ 引入方式 <ul><li>行内样式</li><li>内部样式表</li><li>外部样式表</li></ul></li><li>⭐️ 选择器 <ul><li>通用选择器</li><li>标签选择器</li><li>id 选择器</li><li>class 选择器</li><li>属性选择器</li><li>派生选择器 <ul><li>后代选择器</li><li>子元素选择器</li><li>相邻兄弟选择器</li></ul></li><li>组合选择器</li><li>伪选择器</li><li>选择器优先级</li></ul></li><li>⭐️ 属性 <ul><li>单位 <ul><li>px</li><li>em</li><li>rem</li><li>vw</li><li>vh</li></ul></li><li>背景</li><li>文本</li><li>字体</li><li>列表</li><li>表格</li></ul></li><li>⭐️ 文档流 <ul><li>标准流</li><li>浮动流</li><li>定位流</li></ul></li><li>⭐️ 内联元素 / 块状元素 </li><li>⭐️ 盒子模型 <ul><li>content</li><li>padding</li><li>border</li><li>margin</li></ul></li><li>⭐️ 浮动 <ul><li>设置浮动 float</li><li>清除浮动 clear</li></ul></li><li>⭐️ 定位 <ul><li>static</li><li>absolute</li><li>fixed</li><li>relative</li><li>sticky</li></ul></li><li>⭐️ 层叠规则 </li><li>❗ BFC 和 IFC 机制 </li><li>CSS3 <ul><li>⭐️ 响应式布局 <ul><li>媒体查询</li><li>Flex 布局</li><li>Grid 布局</li><li>瀑布流</li></ul></li><li>动画</li><li>过渡</li><li>渐变</li><li>背景</li><li>边框</li><li>圆角</li><li>字体</li><li>2D / 3D 转换</li></ul></li></ul><h3 id="⭐️-JavaScript"><a href="#⭐️-JavaScript" class="headerlink" title="⭐️ JavaScript"></a>⭐️ JavaScript</h3><ul><li>💬 描述：具有函数优先的轻量级，解释型或即时编译型的编程语言。 </li><li>📚 资源：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</a> </li><li>⭐️ 基本语法 </li><li>⭐️ 数据类型 <ul><li>值类型 <ul><li>字符串 String</li><li>数组 Number</li><li>布尔 Boolean</li><li>空值 Null</li><li>未定义 Undefined</li><li>Symbol</li></ul></li><li>引用类型 <ul><li>对象 Object</li><li>数组 Array</li><li>函数 Function</li></ul></li></ul></li><li>✅ 数据类型转换 </li><li>✅ 函数 <ul><li>⭐️ 概念</li><li>⭐️ 自定义函数</li><li>调用方式 <ul><li>⭐️ 全局调用</li><li>构造函数调用</li><li>⭐️ 函数方法调用</li><li>apply</li><li>call</li></ul></li><li>✅❗ 闭包</li></ul></li><li>✅ 对象 <ul><li>概念</li><li>this</li><li>原型链和继承</li><li>常用对象 <ul><li>数字 Number</li><li>字符串 String 对象</li><li>日期 Date 对象</li><li>数组 Array</li><li>布尔 Boolean</li><li>算数 Math</li></ul></li><li>自定义对象</li></ul></li><li>✅❗ 作用域（作用域链） </li><li>✅ BOM API </li><li>⭐️ DOM API </li><li>⭐️ JSON </li><li>⭐️ Ajax </li><li>✅ JavaScript 执行机制 </li></ul><h4 id="✅-ES6-特性"><a href="#✅-ES6-特性" class="headerlink" title="✅ ES6+ 特性"></a>✅ ES6+ 特性</h4><ul><li>💬 描述：新引入的 JavaScript 语法特性。 </li><li>📚 资源：ES6 入门教程 <a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">https://es6.ruanyifeng.com/</a> </li><li>let 和 const </li><li>变量解构赋值 </li><li>对象扩展和新增方法 </li><li>Symbol </li><li>Set 和 Map 数据结构 </li><li>⭐️❗ Promise &amp; async / await 异步编程 </li><li>Generator 函数异步编程 </li></ul><h2 id="二、巩固基础"><a href="#二、巩固基础" class="headerlink" title="二、巩固基础"></a>二、巩固基础</h2><ul><li>💬 描述：学习前端、计算机、软件开发相关基础知识，并复习巩固上阶段学到的前端三件套。 </li><li>📚 资源 <ul><li>《JavaScript 高级程序设计》：<a href="https://t.zsxq.com/0eKWGbTgL" target="_blank" rel="noopener">https://t.zsxq.com/0eKWGbTgL</a></li><li>《JavaScript 忍者秘籍》：<a href="https://www.code-nav.cn/rd/?rid=28ee4e3e606b16c00e3c5b18609e3dc2" target="_blank" rel="noopener">https://www.code-nav.cn/rd/?rid=28ee4e3e606b16c00e3c5b18609e3dc2</a></li></ul></li><li>🎯 目标：熟悉前端三件套语法，尤其是 JavaScript，并了解互联网、域名、浏览器、服务器等，扎实前端程序员的基本功，为下面进入实战开发做准备。 </li></ul><h3 id="前端基础知识"><a href="#前端基础知识" class="headerlink" title="前端基础知识"></a>前端基础知识</h3><ul><li>✅ 互联网 </li><li>⭐️ 域名 </li><li>⭐️ DNS </li><li>⭐️ 服务器 </li><li>✅ 浏览器 <ul><li>浏览器 DOM 事件流 / 事件委托</li><li>⭐️ 浏览器加载顺序</li><li>⭐️ 浏览器渲染过程</li><li>浏览器事件循环</li><li>浏览器同源策略</li><li>❗ 跨域解决方案</li><li>浏览器缓存</li><li>控制台调试技巧</li></ul></li><li>✅ HTTP <ul><li>❗ HTTP 请求过程</li><li>常见 HTTP 协议 <ul><li>HTTP 1.0</li><li>⭐️ HTTP 1.1</li><li>HTTP 2</li><li>HTTP 3</li></ul></li><li>⭐️ HTTP 请求类别</li><li>⭐️ 常见状态码 <ul><li>1xx 信息</li><li>2xx 成功</li><li>3xx 重定向</li><li>4xx 客户端错误</li><li>5xx 服务器错误</li></ul></li><li>WebSocket</li><li>⭐️ Cookie</li><li>Session</li><li>⭐️ HTTPS</li></ul></li></ul><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><h4 id="✅-算法和数据结构"><a href="#✅-算法和数据结构" class="headerlink" title="✅ 算法和数据结构"></a>✅ 算法和数据结构</h4><ul><li>⭐️ 时间 / 空间复杂度分析 </li><li>数据结构 <ul><li>数组</li><li>字符串</li><li>队列</li><li>栈</li><li>链表</li><li>集合</li><li>哈希表</li><li>二叉树</li></ul></li><li>算法 <ul><li>排序</li><li>双指针</li><li>查找</li><li>分治</li><li>动态规划</li><li>递归</li><li>回溯</li><li>贪心</li><li>位运算</li><li>DFS</li><li>BFS</li><li>图</li></ul></li></ul><h4 id="✅-计算机网络"><a href="#✅-计算机网络" class="headerlink" title="✅ 计算机网络"></a>✅ 计算机网络</h4><ul><li>HTTP 协议</li><li>网络模型</li><li>UDP / TCP 协议</li></ul><h4 id="✅-操作系统"><a href="#✅-操作系统" class="headerlink" title="✅ 操作系统"></a>✅ 操作系统</h4><ul><li>进程、线程</li><li>进程 / 线程间通讯方式</li><li>进程调度算法</li><li>进程 / 线程状态</li><li>死锁</li><li>内存管理</li></ul><h3 id="软件开发基础"><a href="#软件开发基础" class="headerlink" title="软件开发基础"></a>软件开发基础</h3><h4 id="✅-设计模式"><a href="#✅-设计模式" class="headerlink" title="✅ 设计模式"></a>✅ 设计模式</h4><ul><li>单例模式</li><li>代理模式</li><li>工厂模式</li><li>装饰者模式</li><li>观察者模式</li><li>策略模式</li><li>门面模式</li></ul><h4 id="⭐️-Git-版本控制"><a href="#⭐️-Git-版本控制" class="headerlink" title="⭐️ Git 版本控制"></a>⭐️ Git 版本控制</h4><ul><li>常用命令</li></ul><h4 id="✅-Linux-服务器"><a href="#✅-Linux-服务器" class="headerlink" title="✅ Linux 服务器"></a>✅ Linux 服务器</h4><ul><li>常用命令</li></ul><h4 id="✅-正则表达式"><a href="#✅-正则表达式" class="headerlink" title="✅ 正则表达式"></a>✅ 正则表达式</h4><h2 id="三、前端工程化"><a href="#三、前端工程化" class="headerlink" title="三、前端工程化"></a>三、前端工程化</h2><ul><li>💬 描述：前端工程化是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的为了提高开发过程中的开发效率，减少不必要的重复工作时间。 </li><li>📚 资源 <ul><li>什么是前端工程化？<a href="https://www.zhihu.com/question/433854153/answer/1713597311" target="_blank" rel="noopener">https://www.zhihu.com/question/433854153/answer/1713597311</a></li></ul></li><li>🎯 目标：至少学会一门主流的前端开发框架（Vue / React），并配合脚手架、组件库、工具等从 0 开始独立搭建并开发一个完整的前端网站，可以试着仿一些知名站点。要求遵循企业开发规范，将项目代码提交到代码仓库中，并独立发布上线，供他人访问。此外，建议抓住机会参与一些团队项目，感受团队开发模式和前端工程化的优势。 </li></ul><h3 id="⭐️-研发流程"><a href="#⭐️-研发流程" class="headerlink" title="⭐️ 研发流程"></a>⭐️ 研发流程</h3><ol><li>技术选型</li><li>初始化</li><li>开发</li><li>本地测试</li><li>代码提交</li><li>编译、打包、构建</li><li>部署</li><li>集成测试</li><li>发布上线</li><li>监控运维</li></ol><h3 id="⭐️-代码托管"><a href="#⭐️-代码托管" class="headerlink" title="⭐️ 代码托管"></a>⭐️ 代码托管</h3><ul><li>💬 描述：集中存储、备份你的代码，还能和团队成员协作开发。 </li><li>⭐️ GitHub </li><li>Gitee </li><li>GitLab </li></ul><h3 id="✅-Node-JS"><a href="#✅-Node-JS" class="headerlink" title="✅ Node.JS"></a>✅ Node.JS</h3><ul><li>💬 描述：一个开源与跨平台的 JavaScript 运行时环境。 它是一个可用于几乎任何项目的流行工具！</li><li>📚 资源 <ul><li>Node.js 官方教程：<a href="http://nodejs.cn/learn" target="_blank" rel="noopener">http://nodejs.cn/learn</a></li><li>Node.js 入门：<a href="https://cnodejs.org/getstart" target="_blank" rel="noopener">https://cnodejs.org/getstart</a></li></ul></li></ul><h4 id="⭐️-包管理"><a href="#⭐️-包管理" class="headerlink" title="⭐️ 包管理"></a>⭐️ 包管理</h4><ul><li>💬 描述：用于安装 Node.js 的扩展、工具等。 </li><li>⭐️ npm </li><li>⭐️ yarn </li><li>❌ bower </li><li>✅ npx </li></ul><h4 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h4><ul><li>Express</li><li>Koa</li><li>Egg</li></ul><h3 id="开发框架-1"><a href="#开发框架-1" class="headerlink" title="开发框架"></a>开发框架</h3><ul><li>💬 描述：解决特定的问题,提高<em>开发</em>效率、简化我们的代码复杂度。</li></ul><h4 id="⭐️-CSS-框架"><a href="#⭐️-CSS-框架" class="headerlink" title="⭐️ CSS 框架"></a>⭐️ CSS 框架</h4><ul><li>✅ BootStrap</li><li>⭐️ Tailwind CSS</li></ul><h4 id="⭐️-JavaScript-框架"><a href="#⭐️-JavaScript-框架" class="headerlink" title="⭐️ JavaScript 框架"></a>⭐️ JavaScript 框架</h4><h5 id="⭐️-Vue"><a href="#⭐️-Vue" class="headerlink" title="⭐️ Vue"></a>⭐️ Vue</h5><ul><li>Vue Router</li><li>Vuex</li></ul><h5 id="⭐️-React"><a href="#⭐️-React" class="headerlink" title="⭐️ React"></a>⭐️ React</h5><ul><li>React DOM</li><li>React Router</li><li>Redux</li><li>MobX</li><li>React Hooks</li></ul><h5 id="❌-Angular"><a href="#❌-Angular" class="headerlink" title="❌ Angular"></a>❌ Angular</h5><ul><li>RxJS</li><li>NgRx</li></ul><h5 id="✅-Svelte"><a href="#✅-Svelte" class="headerlink" title="✅ Svelte"></a>✅ Svelte</h5><h5 id="✅-UmiJS"><a href="#✅-UmiJS" class="headerlink" title="✅ UmiJS"></a>✅ UmiJS</h5><h3 id="封装库"><a href="#封装库" class="headerlink" title="封装库"></a>封装库</h3><h4 id="⭐️-组件库"><a href="#⭐️-组件库" class="headerlink" title="⭐️ 组件库"></a>⭐️ 组件库</h4><ul><li>✅ LayUI</li><li>⭐️ ElementUI（Vue）</li><li>✅ VantUI（Vue）</li><li>⭐️ Ant Design（React）</li><li>Material UI</li></ul><h4 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h4><ul><li>✅ AntV</li><li>Apache ECharts</li><li>HighCharts</li><li>D3.js</li></ul><h4 id="组件（插件）"><a href="#组件（插件）" class="headerlink" title="组件（插件）"></a>组件（插件）</h4><ul><li>富文本编辑器</li><li>弹窗</li><li>轮播图</li></ul><h4 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h4><ul><li>✅ jQuery</li><li>✅ Lodash</li><li>✅ Axios</li><li>时间处理 Moment.js</li></ul><h4 id="动效库"><a href="#动效库" class="headerlink" title="动效库"></a>动效库</h4><ul><li>✅ Animate.css</li><li>Ant Motion</li></ul><h4 id="字体图标库"><a href="#字体图标库" class="headerlink" title="字体图标库"></a>字体图标库</h4><ul><li>⭐️ IconFont</li><li>IconPark</li><li>Font Awesome</li></ul><h3 id="⭐️-脚手架"><a href="#⭐️-脚手架" class="headerlink" title="⭐️ 脚手架"></a>⭐️ 脚手架</h3><ul><li>💬 描述：快速生成新项目的目录模板，提升开发效率和开发舒适性。 </li><li>📚 资源：<a href="https://www.jianshu.com/p/25ce8cf2e6a7" target="_blank" rel="noopener">https://www.jianshu.com/p/25ce8cf2e6a7</a> </li><li>Vue CLI </li><li>create-react-app </li><li>✅ Yeoman </li></ul><h3 id="⭐️-前端架构设计"><a href="#⭐️-前端架构设计" class="headerlink" title="⭐️ 前端架构设计"></a>⭐️ 前端架构设计</h3><ul><li>💬 描述：一系列工具和流程的集合，旨在提升前端代码的质量，并实现高效可持续的工作流。 </li><li>模块化 </li><li>组件化 </li><li>✅ MVVM </li><li>设计原则 </li><li>⭐️ SPA 单页应用 </li><li>⭐️ 多页应用 </li><li>✅ 前端路由 </li><li>PWA </li><li>有损服务 </li></ul><h4 id="✅-服务端渲染"><a href="#✅-服务端渲染" class="headerlink" title="✅ 服务端渲染"></a>✅ 服务端渲染</h4><ul><li>💬 描述：在服务端渲染 HTML 页面的模式。 </li><li>📚 资源：<a href="https://www.zhihu.com/question/379563505" target="_blank" rel="noopener">https://www.zhihu.com/question/379563505</a> </li><li>Next.js（React） </li><li>Nuxt.js（Vue） </li><li>❌ Universal（Angular） </li></ul><h4 id="BFF"><a href="#BFF" class="headerlink" title="BFF"></a>BFF</h4><ul><li>💬 描述：Backend For Frontend（服务于前端的后端），就是服务器设计 API 时会考虑前端的使用，并在服务端直接进行业务逻辑的处理。 </li><li>📚 资源：<a href="https://www.jianshu.com/p/eb1875c62ad3" target="_blank" rel="noopener">https://www.jianshu.com/p/eb1875c62ad3</a> </li><li>GraphQL </li></ul><h4 id="✅-微前端"><a href="#✅-微前端" class="headerlink" title="✅ 微前端"></a>✅ 微前端</h4><ul><li>💬 描述：将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的小块，从而解决庞大的一整块后端服务带来的变更与扩展方面的限制。 </li><li>📚 资源：<a href="https://zhuanlan.zhihu.com/p/96464401" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/96464401</a> </li><li>qiankun </li><li>single-spa </li></ul><h3 id="CSS-in-JS"><a href="#CSS-in-JS" class="headerlink" title="CSS in JS"></a>CSS in JS</h3><ul><li>💬 描述：用 JavaScript 来写 CSS。 </li><li>📚 资源：<a href="http://www.ruanyifeng.com/blog/2017/04/css_in_js.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/04/css_in_js.html</a> </li><li>内联样式 </li><li>声明样式 </li><li>引入样式 </li></ul><h4 id="⭐️-CSS-模块化"><a href="#⭐️-CSS-模块化" class="headerlink" title="⭐️ CSS 模块化"></a>⭐️ CSS 模块化</h4><ul><li>⭐️ CSS Modules</li><li>✅ styled-components</li><li>✅ Styled JSX</li><li>Emotion</li></ul><h3 id="✅-开发调试"><a href="#✅-开发调试" class="headerlink" title="✅ 开发调试"></a>✅ 开发调试</h3><ul><li>💬 描述：本地开发时热更新，提升开发效率。 </li><li>webpack-dev-server </li><li>serve </li></ul><h4 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h4><ul><li>💬 描述：将内网外网通过 nat 隧道打通，让内网的网站、数据让外网可以访问。 </li><li>Ngrok </li><li>NATAPP </li></ul><h3 id="⭐️-CSS-预编译"><a href="#⭐️-CSS-预编译" class="headerlink" title="⭐️ CSS 预编译"></a>⭐️ CSS 预编译</h3><ul><li>💬 描述：使用新的扩展语言以增强 CSS 的能力，并通过预编译的方式将其转换为浏览器认识的 CSS 代码。 </li><li>⭐️ SASS </li><li>✅ PostCSS </li><li>Stylus </li><li>❌ LESS </li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h4><ul><li>⭐️ UT 单元测试</li><li>SIT 系统集成测试</li><li>E2E 端到端测试</li><li>UAT 用户验收测试</li></ul><h4 id="✅-Mock"><a href="#✅-Mock" class="headerlink" title="✅ Mock"></a>✅ Mock</h4><ul><li>💬 描述：通过随机数据，模拟各种场景，增加单元测试的真实性。 </li><li>Mock.js </li></ul><h4 id="✅-测试框架"><a href="#✅-测试框架" class="headerlink" title="✅ 测试框架"></a>✅ 测试框架</h4><ul><li>✅ Jest </li><li>Enzyme </li><li>✅ Puppeteer（Headless Browser） </li><li>Mocha </li><li>Jasmine </li></ul><h3 id="✅-代码质量"><a href="#✅-代码质量" class="headerlink" title="✅ 代码质量"></a>✅ 代码质量</h3><h4 id="开发规范"><a href="#开发规范" class="headerlink" title="开发规范"></a>开发规范</h4><ul><li>💬 描述：依照规范写出的代码会更加合理。 </li><li>📚 资源：Airbnb 代码规范 <a href="https://github.com/BingKui/javascript-zh" target="_blank" rel="noopener">https://github.com/BingKui/javascript-zh</a> </li><li>CSS Style Guide </li><li>JavaScript Style Guide </li></ul><h4 id="类型校验"><a href="#类型校验" class="headerlink" title="类型校验"></a>类型校验</h4><ul><li>TypeScript</li></ul><h4 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a>代码检查</h4><ul><li>ESLint</li><li>StyleLint</li></ul><h4 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h4><ul><li>💬 描述：根据配置自动格式化代码，统一格式。 </li><li>Prettier </li></ul><h4 id="提交规范"><a href="#提交规范" class="headerlink" title="提交规范"></a>提交规范</h4><ul><li>约定式提交</li></ul><h4 id="提交检查"><a href="#提交检查" class="headerlink" title="提交检查"></a>提交检查</h4><ul><li>💬 描述：在提交代码时触发一些操作，比如检查代码的风格等。 </li><li>pre-commit </li><li>husky </li></ul><h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><h4 id="自动化构建"><a href="#自动化构建" class="headerlink" title="自动化构建"></a>自动化构建</h4><ul><li>💬 描述：按照配置好的流程自动打包构建项目，提高团队的开发效率，降低项目的维护难度。 </li><li>Gulp </li><li>✅ npm script </li><li>Grunt </li></ul><h4 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h4><ul><li>💬 描述：将各种零散的📚 资源文件打包为可在浏览器等环境运行的代码。 </li><li>⭐️ Webpack </li><li>✅ Rollup </li><li>✅ Vite </li><li>Parcel </li><li>Snowpack </li></ul><h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI / CD"></a>CI / CD</h3><ul><li>💬 描述：通过在应用开发阶段引入自动化来频繁向客户交付应用。</li><li>GitLab CI</li><li>✅ Jenkins</li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="⭐️-Web-服务器"><a href="#⭐️-Web-服务器" class="headerlink" title="⭐️ Web 服务器"></a>⭐️ Web 服务器</h4><h5 id="⭐️-Nginx"><a href="#⭐️-Nginx" class="headerlink" title="⭐️ Nginx"></a>⭐️ Nginx</h5><ul><li>💬 描述：高性能的 HTTP 和反向代理 web 服务器。 </li><li>📚 资源：腾讯云动手实验室 <a href="https://cloud.tencent.com/developer/labs/gallery" target="_blank" rel="noopener">https://cloud.tencent.com/developer/labs/gallery</a> </li><li>反向代理 </li><li>解决跨域 </li><li>改写请求 </li></ul><h5 id="✅-Apache"><a href="#✅-Apache" class="headerlink" title="✅ Apache"></a>✅ Apache</h5><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><h5 id="✅-Docker"><a href="#✅-Docker" class="headerlink" title="✅ Docker"></a>✅ Docker</h5><ul><li>💬 描述：容器是一个标准化的软件单元，它将代码及其所有依赖关系打包，以便应用程序从一个计算环境可靠快速地运行到另一个计算环境。Docker容器镜像是一个轻量的独立的可执行的软件包。包含程序运行的时候所需的一切：代码，运行时间，系统工具，系统库和设置。 </li><li>📚 资源：Docker 从入门到实践 <a href="https://vuepress.mirror.docker-practice.com/" target="_blank" rel="noopener">https://vuepress.mirror.docker-practice.com/</a> </li><li>Dockerfile </li></ul><h5 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h5><h4 id="部署策略"><a href="#部署策略" class="headerlink" title="部署策略"></a>部署策略</h4><ul><li>全量发布</li><li>蓝绿部署</li><li>滚动发布</li><li>灰度发布</li></ul><h3 id="监控告警"><a href="#监控告警" class="headerlink" title="监控告警"></a>监控告警</h3><ul><li>前端埋点</li><li>错误监控</li><li>性能监控</li><li>行为监控</li></ul><h2 id="四、前端优化"><a href="#四、前端优化" class="headerlink" title="四、前端优化"></a>四、前端优化</h2><ul><li>💬 描述：通过分析和优化手段，提高网站的性能和用户体验。 </li><li>🎯 目标：实践前端优化方法，从多个方面优化自己做过的项目，最好能将优化后的网站与原网站进行对比，得到一些数据和体验上的明显提升。 </li></ul><h3 id="✅-性能优化"><a href="#✅-性能优化" class="headerlink" title="✅ 性能优化"></a>✅ 性能优化</h3><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><ul><li>💬 描述：用于衡量一个 Web 页面的性能。 </li><li>📚 资源：<a href="https://juejin.cn/post/6844904153869713416" target="_blank" rel="noopener">https://juejin.cn/post/6844904153869713416</a> </li><li>FP（First Paint） <ul><li>💬 描述：从开始加载到浏览器首次绘制像素到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间。</li></ul></li><li>FCP（First Contentful Paint） <ul><li>💬 描述：浏览器首次绘制来自 DOM 的内容的时间。</li></ul></li><li>FMP（First Meaningful Paint） <ul><li>💬 描述：页面的主要内容绘制到屏幕上的时间。</li></ul></li><li>FSP（First Screen Paint） <ul><li>💬 描述：页面从开始加载到首屏内容全部绘制完成的时间，用户可以看到首屏的全部内容。</li></ul></li><li>TTI（Time to Interactive） <ul><li>💬 描述：表示网页第一次完全达到可交互状态的时间点，浏览器已经可以持续性的响应用户的输入。</li></ul></li></ul><h4 id="优化手段"><a href="#优化手段" class="headerlink" title="优化手段"></a>优化手段</h4><ul><li>性能监控 <ul><li>Performance API</li></ul></li><li>样式优化 </li><li>JavaScript 优化 <ul><li>防抖</li><li>节流</li></ul></li><li>代码分割 </li><li>📚 资源压缩 </li><li>打包优化 </li><li>服务器优化 </li><li>缓存优化 <ul><li>Service Worker</li></ul></li><li>动画性能 </li><li>dns-prefetch </li><li>Lazy loading </li><li>优化启动性能 <ul><li>异步化</li></ul></li><li>渲染优化 </li><li>网络优化 </li><li>移动端性能优化 </li><li>✅ CDN <ul><li>💬 描述：内容分发网络，是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</li><li>📚 资源：BootCDN <a href="https://www.bootcdn.cn/" target="_blank" rel="noopener">https://www.bootcdn.cn/</a></li></ul></li></ul><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><ul><li>设计系统</li><li>骨架屏</li></ul><h3 id="✅-兼容性"><a href="#✅-兼容性" class="headerlink" title="✅ 兼容性"></a>✅ 兼容性</h3><h4 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h4><ul><li>normalize.css</li><li>html5shiv.js</li><li>respond.js</li><li>Babel</li><li>Polyfill</li></ul><h4 id="屏幕分辨率兼容性"><a href="#屏幕分辨率兼容性" class="headerlink" title="屏幕分辨率兼容性"></a>屏幕分辨率兼容性</h4><h4 id="跨平台兼容性"><a href="#跨平台兼容性" class="headerlink" title="跨平台兼容性"></a>跨平台兼容性</h4><h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><ul><li>💬 描述：搜索引擎优化，利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。 </li><li>📚 资源：百度搜索📚 资源平台 <a href="https://ziyuan.baidu.com/cooperateresource/index" target="_blank" rel="noopener">https://ziyuan.baidu.com/cooperateresource/index</a> </li><li>robots.txt </li><li>description </li><li>keywords </li><li>SiteMap </li><li>HTML 标签优化 </li><li>站内链接建设 </li><li>友情链接 </li></ul><h3 id="✅-安全"><a href="#✅-安全" class="headerlink" title="✅ 安全"></a>✅ 安全</h3><ul><li>⭐️ XSS</li><li>CSRF</li><li>反爬虫</li><li>SQL 注入</li><li>DDoS</li></ul><h2 id="五、前端生态"><a href="#五、前端生态" class="headerlink" title="五、前端生态"></a>五、前端生态</h2><ul><li>💬 描述：如今，前端领域的范围越来越广，出现了更多前端工程师需要了解和关注的技术。 </li><li>🎯 目标：能用学到的前端技术去做更多的事情，比如开发个人博客、文档网站、小程序、APP 等。 </li></ul><h3 id="⭐️-静态站点构建"><a href="#⭐️-静态站点构建" class="headerlink" title="⭐️ 静态站点构建"></a>⭐️ 静态站点构建</h3><h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><ul><li>React Static</li></ul><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><ul><li>✅ Gatsby.js</li><li>✅ Docusaurus</li><li>Hugo</li><li>Hexo</li></ul><h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><ul><li>JekyII</li><li>⭐️ Docsify</li><li>VuePress</li><li>✅ Dumi</li></ul><h3 id="✅-大前端"><a href="#✅-大前端" class="headerlink" title="✅ 大前端"></a>✅ 大前端</h3><p>💬 描述：前端技术的融合更加紧密，应用的领域也更加广泛，前端领域的内容呈现多样化，除了网站外，还可以用前端技术跨平台开发 Android、iOS、小程序、虚拟现实、增强现实等。</p><h4 id="移动应用"><a href="#移动应用" class="headerlink" title="移动应用"></a>移动应用</h4><ul><li>Hybrid</li><li>WebView</li><li>React Native</li><li>Flutter</li></ul><h4 id="移动应用打包"><a href="#移动应用打包" class="headerlink" title="移动应用打包"></a>移动应用打包</h4><ul><li>Weex</li><li>Cordova</li><li>Phonegap</li><li>Ionic</li></ul><h4 id="桌面应用"><a href="#桌面应用" class="headerlink" title="桌面应用"></a>桌面应用</h4><ul><li>Electron</li><li>NW.js</li><li>Proton Native</li></ul><h4 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h4><ul><li>原生</li><li>WebView</li></ul><h4 id="跨端开发框架"><a href="#跨端开发框架" class="headerlink" title="跨端开发框架"></a>跨端开发框架</h4><ul><li>✅ uni-app</li><li>✅ Taro</li><li>Flutter</li><li>Chameleon</li><li>Wepy</li><li>Rax</li></ul><h4 id="移动端调试"><a href="#移动端调试" class="headerlink" title="移动端调试"></a>移动端调试</h4><ul><li>Chrome Dev Tools</li><li>Android Simulator</li><li>IOS Simulator</li></ul><h3 id="✅-Serverless"><a href="#✅-Serverless" class="headerlink" title="✅ Serverless"></a>✅ Serverless</h3><ul><li>💬 描述：一种构建和管理基于微服务架构的完整流程，允许你在服务部署级别而不是服务器部署级别来管理你的应用部署，你甚至可以管理某个具体功能或端口的部署，这就能让开发者快速迭代，更快速地开发软件。</li></ul><h3 id="✅-云开发"><a href="#✅-云开发" class="headerlink" title="✅ 云开发"></a>✅ 云开发</h3><ul><li>💬 描述：云端一体化的后端云服务 ，采用 Serverless 架构，免去了移动应用构建中繁琐的服务器搭建和运维。同时云开发提供的静态托管、命令行工具（CLI）、Flutter SDK 等能力降低了应用开发的门槛。使用云开发可以构建完整的小程序/小游戏、H5、Web、移动 App 等应用。 </li><li>✅ 腾讯云云开发 </li><li>阿里云云开发 </li></ul><h3 id="低代码"><a href="#低代码" class="headerlink" title="低代码"></a>低代码</h3><ul><li>💬 描述：无需编码（零代码）或通过少量代码就可以快速生成应用程序的开发平台。通过可视化进行应用程序开发的方法，使具有不同经验水平的开发人员可以通过图形化的用户界面，使用拖拽组件和模型驱动的逻辑来创建网页和移动应用程序。 </li><li>腾讯云低码 </li><li>阿里宜搭 </li></ul><h2 id="六、前端求职"><a href="#六、前端求职" class="headerlink" title="六、前端求职"></a>六、前端求职</h2><ul><li>💬 描述：求职是一个漫长的过程，建议拉长战线，尽早准备。 </li><li>🎯 目标：找到理想的工作。 </li></ul><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><ul><li>老鱼简历：<a href="https://laoyujianli.com/" target="_blank" rel="noopener">https://laoyujianli.com/</a>（1 分钟帮你生成精美的个人简历）</li></ul><h3 id="面试题库"><a href="#面试题库" class="headerlink" title="面试题库"></a>面试题库</h3><ul><li>编程导航精选面试题汇总：<a href="https://yuyuanweb.feishu.cn/wiki/CmFywXs0Oi0MS9kU3yocJugFn2e" target="_blank" rel="noopener">https://yuyuanweb.feishu.cn/wiki/CmFywXs0Oi0MS9kU3yocJugFn2e</a></li><li>前端面试每日 3+1：<a href="https://github.com/haizlin/fe-interview" target="_blank" rel="noopener">https://github.com/haizlin/fe-interview</a></li><li>React 面试题目 &amp; 题解：<a href="https://github.com/sudheerj/reactjs-interview-questions" target="_blank" rel="noopener">https://github.com/sudheerj/reactjs-interview-questions</a></li></ul><h3 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h3><ul><li>编程导航面经汇总：<a href="https://yuyuanweb.feishu.cn/wiki/PLHrwcEPCiJcxXk7Ki4csRoJn2f" target="_blank" rel="noopener">https://yuyuanweb.feishu.cn/wiki/PLHrwcEPCiJcxXk7Ki4csRoJn2f</a></li></ul><h2 id="七、前端未来"><a href="#七、前端未来" class="headerlink" title="七、前端未来"></a>七、前端未来</h2><ul><li>💬 描述：前端未来可能的发展趋势和热门技术。 </li><li>🎯 目标：关注前沿，持续进步。 </li><li>WebAssembly </li><li>智能 UI </li><li>React Server Component </li><li>CSS Houdini </li></ul><h3 id="WebComponents"><a href="#WebComponents" class="headerlink" title="WebComponents"></a>WebComponents</h3><ul><li>HTML templates（HTML模板）</li><li>Custom elements（自定义元素）</li><li>Shadow DOM（影子DOM）</li></ul><h2 id="我的前端学习路线"><a href="#我的前端学习路线" class="headerlink" title="我的前端学习路线"></a>我的前端学习路线</h2><p>虽然上面整理的学习路线知识点非常多，但是大家也别太担心，其实按照一定顺序和方法来学习，并不会很难，聊聊我的学习经历。</p><h3 id="1-快速入门，培养兴趣"><a href="#1-快速入门，培养兴趣" class="headerlink" title="1. 快速入门，培养兴趣"></a>1. 快速入门，培养兴趣</h3><p>刚开始学习前端时，一定要以培养兴趣、快速入门为目标。我入门前端时，由于没有基础、啥都不懂，因此选择在线实战教程网站来学习，跟着教程案例一行行把代码敲下来，实时浏览显示效果，很轻松地就把 HTML、CSS、JavaScript 的语法基础过了一遍。但是这时，我对看过的知识点没有什么印象，基本是看了就忘，当我想要自己写一个网站，也根本无从下手。</p><p>于是，我开始试着死记硬背代码，结果发现背了之后还是不会写。那干脆一不做二不休，直接打开编辑器和教程网站，把之前在线实战时敲过的代码复制粘贴到编辑器中，然后再修改保存，到浏览器中打开文件。这样虽然要在编辑器和浏览器中来回切换，但起码能看到自己的网页文件运行的效果了。后来，我利用浏览器开发者工具提升了自己开发网站的调试效率，敲出的代码达不到满意的效果时，就再去查，再改，再浏览，最后终于完成了一个留言板网站！</p><p>通过这件事，我明白了一个道理，既然记不住知识，那就先别强行记忆，上手多写，忘了就去查不就好了？不要担心自己知识不够做不出来，只要你去试，都一定能实现。</p><h3 id="2-多看多写，巩固基础"><a href="#2-多看多写，巩固基础" class="headerlink" title="2. 多看多写，巩固基础"></a>2. 多看多写，巩固基础</h3><p>在这种操作下，我虽然能使用基础三件套开发简易网站了，但做的很慢，还老出问题。于是，我开始完整地看了几本前端入门和项目实战书籍，有三件套入门的，也有响应式网站设计的，还有 JavaScript 综合讲解的，以及一套完整的视频教程，通过这些来复习巩固之前学过的知识，打好了基础，并且了解了更多实战教程上没见到的知识。</p><p>看书和视频的过程中，我跟着做了几个简易的网站，也是边看边做。在这之后，我发现自己渐渐地能够脱离文档来写网站了！</p><h3 id="3-框架学习，学以致用"><a href="#3-框架学习，学以致用" class="headerlink" title="3. 框架学习，学以致用"></a>3. 框架学习，学以致用</h3><p>但是，总感觉开发网站时，什么都要自己写，重复的代码写一大堆，很麻烦。于是，我试着上网搜了解决这些问题的方法，发现可以用组件库减少重复编写 HTML 和 CSS 代码，于是学了 LayUI，其实和之前一样的，就是打开官网找到要用的组件，然后复制到项目中修改就行了，写的多了竟然还真记住了一些（虽然这个没必要记）。</p><p>界面和样式代码简化了，但是 JavaScript 写的我依旧头疼。于是我决定进入下一个阶段的学习，当时先看了本书叫《锋利的 jQuery》来学习 jQuery，学会之后使用它趁热打铁做了几个网站，发现的确能大大简化繁琐的 JavaScript DOM 操作，让我尝到了甜头，又有了继续学习前端的动力。</p><p>在那之后大概半年，我开始学习主流前端框架 Vue，也是跟着视频教程学，并且结合 ElementUI 组件库开发了一个响应式网站。不得不说，习惯了用原生 JavaScript 和 jQuery 开发后，再去用 Vue 开发，真的是爽飞了，小有成就感。</p><h3 id="4-根据需要，自主学习"><a href="#4-根据需要，自主学习" class="headerlink" title="4. 根据需要，自主学习"></a>4. 根据需要，自主学习</h3><p>在那之后，我就是通过不断地做项目来积累经验，既然编程知识太多学不完，那我就随需随学，逐渐拓宽自己的知识面。举个例子，我要做一个移动端 H5 页面，那就去搜 Vue 的移动端组件库，学会了 MintUI、VantUI 等；项目中要处理日期，那我就去搜日期处理库，学会了 Moment.js；项目重复文件和代码太多，我就去网上搜一些组件化、模块化的最佳实践；项目代码太大、加载太慢，我就去网上搜一些前端压缩、性能优化的方式；要把开发好的项目变成 APP，那我就去网上搜到了 Cordova 等打包工具；跟其他同学一起做项目时比较混乱、开发效率低，我就去搜了一些代码规范、前端工程化等；遇到 Bug 时，也是自己去网上搜索解决方案，并且还要看看有没有知识点是我遗漏的，我会再去弥补学习。通过不断实践、不断遇到问题和自主解决问题，我始终保持着学习的积极性，学到了越来越多前端的知识，并通过归纳总结来加深印象。</p><h3 id="5-渐入佳境，拓宽视野"><a href="#5-渐入佳境，拓宽视野" class="headerlink" title="5. 渐入佳境，拓宽视野"></a>5. 渐入佳境，拓宽视野</h3><p>在那之后，我学前端技术非常快了，像 React、TypeScript、Redux、Dva、Umi、Lerna 等等都随用随学，随学随用。此外，我不仅仅关注前端网页开发本身，还同时关注前端的生态和发展，学习了微前端、Serverless、云开发、低代码等技术，因此个人的能力提升也很大。如今在鹅厂工作中也是，面对各种不同技术栈的前端项目，我都能迎难而上，毕竟不会就学嘛！</p><p>哦，写的渐入佳境，我都忘了，自己是一名后端工程师，还搁这儿吹牛逼呢（ 所以本路线难免会有不专业的地方，请大家见谅~</p><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>总结一下，学前端的路线其实就一句话：基础三件套 =&gt; 巩固基础 =&gt; 学习框架 =&gt; 多做项目 =&gt; 按需学习 =&gt; 拓宽视野。还有一个学任何编程技术都要注意的点，全程多敲代码！多敲代码！多敲代码！</p><h2 id="尾声-持续学习"><a href="#尾声-持续学习" class="headerlink" title="尾声 - 持续学习"></a>尾声 - 持续学习</h2><h3 id="前端职业发展的几个阶段"><a href="#前端职业发展的几个阶段" class="headerlink" title="前端职业发展的几个阶段"></a>前端职业发展的几个阶段</h3><ol><li>作为一名合格的前端开发，首先你要能干活、能通过 Vue 之类的前端框架完成公司的需求，比如还原设计稿、开发交互、搭建项目的初始框架（架构）、开发内部的组件库（基建）等等，重点是要学会如何和后端系统进行对接（前后端联调），有时候也需要完成一些简单的服务端开发，比如使用 Node 搭建中间层 / 接入层（BFF）。 </li><li>这就需要你除了学习前端基础三件套之外，还要熟练使用一个开发框架 Vue / React 以及前端工程化的一些工具 / 轮子，比如打包工具用 webpack、性能分析工具、SSR 等），可以帮助你更好地设计项目、开发项目，从而应对需求的变化、使项目更易于维护、可扩展。 </li><li>如果要成为高级前端开发，要了解常用框架 / 工具的运行原理和机制。最好有一个自己擅长 / 专攻的领域，比如低代码、Web IDE、可视化、性能优化、Web Assembly 等等，并且积极参与开源项目和公开分享。</li></ol><p>随着学习知识的不断丰富和深入，要学会主动到网上关注和汲取知识、了解前端的发展和新技术趋势。比如看书、掘金、InfoQ 等技术网站，或者关注某个领域的大佬、参加一些大会等。</p><h3 id="优秀前端人的特质"><a href="#优秀前端人的特质" class="headerlink" title="优秀前端人的特质"></a>优秀前端人的特质</h3><ul><li>深厚的功底 </li><li>良好的编码习惯 </li><li>发现问题的洞察力 </li><li>思维灵活，善于思考 </li><li>追求技术，紧跟前沿 </li><li>有创造力，有行动力 </li><li>追求用户体验 </li><li>时刻保持好奇 </li><li>全栈意识 </li><li>解决问题的能力强 </li><li>懂得合作和高效沟通 </li><li>重视工作，同样重视生活 </li><li>责任心和全局观 </li><li>个人的进步能带动团队的进步 </li></ul><h3 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h3><ul><li>编程导航（包含以下所有资源，强烈推荐 👍）：<a href="https://www.code-nav.cn" target="_blank" rel="noopener">https://www.code-nav.cn</a></li><li>freeCodecamp 在线编程：<a href="https://learn.freecodecamp.one/" target="_blank" rel="noopener">https://learn.freecodecamp.one/</a></li><li>阿里云前端实战学习：<a href="https://edu.aliyun.com/roadmap/frontend" target="_blank" rel="noopener">https://edu.aliyun.com/roadmap/frontend</a></li><li>W3Cschool 编程入门实战：<a href="https://www.w3cschool.cn/codecamp/" target="_blank" rel="noopener">https://www.w3cschool.cn/codecamp/</a></li><li>腾讯云动手实验室：<a href="https://cloud.tencent.com/developer/labs/gallery" target="_blank" rel="noopener">https://cloud.tencent.com/developer/labs/gallery</a></li><li>pink老师前端入门教程：<a href="https://www.bilibili.com/video/BV14J4114768" target="_blank" rel="noopener">https://www.bilibili.com/video/BV14J4114768</a></li><li>MDN 前端文档：<a href="https://developer.mozilla.org/zh-CN" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN</a></li><li>Node.js 入门：<a href="https://cnodejs.org/getstart" target="_blank" rel="noopener">https://cnodejs.org/getstart</a></li><li>前端清单：<a href="https://cheatsheets.devtool.tech/" target="_blank" rel="noopener">https://cheatsheets.devtool.tech/</a></li><li>前端小课：<a href="https://lefex.github.io/" target="_blank" rel="noopener">https://lefex.github.io/</a></li><li>被删的前端游乐场：<a href="http://www.godbasin.com/" target="_blank" rel="noopener">http://www.godbasin.com/</a></li><li>《ES6 入门教程》：<a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">https://es6.ruanyifeng.com/</a></li><li>谷歌 Web 开发者：<a href="https://developers.google.com/web" target="_blank" rel="noopener">https://developers.google.com/web</a></li><li>JavaScript 明星项目：<a href="https://risingstars.js.org/2020/zh" target="_blank" rel="noopener">https://risingstars.js.org/2020/zh</a></li><li>Best of JS：<a href="https://bestofjs.org/" target="_blank" rel="noopener">https://bestofjs.org/</a></li><li>Codewars：<a href="https://www.codewars.com/?language=javascript" target="_blank" rel="noopener">https://www.codewars.com/?language=javascript</a></li><li>Vue.js examples：<a href="https://vuejsexamples.com/" target="_blank" rel="noopener">https://vuejsexamples.com/</a></li></ul><h3 id="前端资讯"><a href="#前端资讯" class="headerlink" title="前端资讯"></a>前端资讯</h3><ul><li>掘金资讯：<a href="https://juejin.cn/news" target="_blank" rel="noopener">https://juejin.cn/news</a></li><li>InfoQ：<a href="https://www.infoq.cn/topic/Front-end" target="_blank" rel="noopener">https://www.infoq.cn/topic/Front-end</a></li><li>daily.dev：<a href="https://daily.dev/" target="_blank" rel="noopener">https://daily.dev/</a></li></ul><h3 id="技术博客"><a href="#技术博客" class="headerlink" title="技术博客"></a>技术博客</h3><ul><li>掘金：<a href="https://juejin.cn/frontend" target="_blank" rel="noopener">https://juejin.cn/frontend</a> </li><li>腾讯前端 IMWEB：<a href="http://imweb.io" target="_blank" rel="noopener">http://imweb.io</a> </li><li>腾讯 Web 前端团队 Alloy Team：<a href="http://www.alloyteam.com" target="_blank" rel="noopener">http://www.alloyteam.com</a> </li><li>淘宝前端团队：<a href="http://taobaofed.org" target="_blank" rel="noopener">http://taobaofed.org</a> </li><li>百度 Web 前端研发部：<a href="http://fex.baidu.com" target="_blank" rel="noopener">http://fex.baidu.com</a> </li><li>京东凹凸实验室：<a href="https://aotu.io" target="_blank" rel="noopener">https://aotu.io</a> </li><li>360 奇舞团：<a href="https://75team.com" target="_blank" rel="noopener">https://75team.com</a> </li><li>七牛团队技术博客：<a href="http://blog.qiniu.com" target="_blank" rel="noopener">http://blog.qiniu.com</a> </li><li>有赞技术团队：<a href="https://tech.youzan.com/tag/front-end/" target="_blank" rel="noopener">https://tech.youzan.com/tag/front-end/</a> </li><li>百度 EFE Tech：<a href="https://efe.baidu.com/" target="_blank" rel="noopener">https://efe.baidu.com/</a> </li><li>css-tricks：<a href="https://css-tricks.com/archives" target="_blank" rel="noopener">https://css-tricks.com/archives</a> </li><li>web.dev：<a href="https://web.dev/blog/" target="_blank" rel="noopener">https://web.dev/blog/</a> </li></ul><h3 id="学习要点"><a href="#学习要点" class="headerlink" title="学习要点"></a>学习要点</h3><ul><li>前期学习以培养兴趣为主，不要过于追求深层理解。</li><li>前端学习不能靠死记硬背，要多敲代码、多做项目实践。</li><li>不要急于求成，踏实积累才是硬道理。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BUAA Computer Network Experiment] Notes</title>
      <link href="/2024/06/12/BUAA-Computer-Network-Experiment-Note/"/>
      <url>/2024/06/12/BUAA-Computer-Network-Experiment-Note/</url>
      
        <content type="html"><![CDATA[<h4 id="实验一-网络实验入门"><a href="#实验一-网络实验入门" class="headerlink" title="实验一 网络实验入门"></a>实验一 网络实验入门</h4><h5 id="交换机和路由器简介"><a href="#交换机和路由器简介" class="headerlink" title="交换机和路由器简介"></a>交换机和路由器简介</h5><ul><li><p>交换机工作在数据链路层，基本功能是在多个计算机或者网段之间交换数据。</p></li><li><p>路由器工作在网络层，基本功能是根据数据包的IP地址选择发送路径，转发数据包到相应网络。</p></li></ul><h5 id="交换机和路由器的基本配置"><a href="#交换机和路由器的基本配置" class="headerlink" title="交换机和路由器的基本配置"></a>交换机和路由器的基本配置</h5><h5 id="地址转换NAT"><a href="#地址转换NAT" class="headerlink" title="地址转换NAT"></a>地址转换NAT</h5><p>配置地址转换，把所有内网地址转换成所配置的地址池中的地址</p><ul><li><p>定义访问控制列表，允许IP源地址为10.0.0.0/24的外出数据包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[R1] acl number 2001</span><br><span class="line">[R1-acl-2001] rule permit source 10.0.0.0 0.0.0.255</span><br><span class="line">[R1-acl-2001] rule deny source any</span><br></pre></td></tr></table></figure></li><li><p>定义一个包含5个公网地址的地址池，地址池名称为1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#v5</span><br><span class="line">[R1] nat address-group 1 192.168.5.105 192.168.5.109</span><br><span class="line">#v7</span><br><span class="line">[R1] nat address-group 1</span><br><span class="line">[R1-address-group-1] address 192.168.5.105 192.168.5.109</span><br></pre></td></tr></table></figure></li><li><p>将访问控制运用到地址池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R1] interface e0&#x2F;1</span><br><span class="line">[R1-Ethernet0&#x2F;1] nat outbound 2001 address-group 1</span><br></pre></td></tr></table></figure></li><li><p>在路由表中添加默认路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1] ip route-static 0.0.0.0 0.0.0.0 192.168.5.1</span><br></pre></td></tr></table></figure></li><li><p>与OSPF结合，还需引入默认路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1-ospf-1] default-route-advertise (cost 100)</span><br></pre></td></tr></table></figure></li></ul><h4 id="实验二-数据链路层实验"><a href="#实验二-数据链路层实验" class="headerlink" title="实验二 数据链路层实验"></a>实验二 数据链路层实验</h4><h5 id="以太网链路层帧格式分析"><a href="#以太网链路层帧格式分析" class="headerlink" title="以太网链路层帧格式分析"></a>以太网链路层帧格式分析</h5><h5 id="交换机的MAC地址表和端口聚合"><a href="#交换机的MAC地址表和端口聚合" class="headerlink" title="交换机的MAC地址表和端口聚合"></a>交换机的MAC地址表和端口聚合</h5><p>区分路由聚合，端口聚合是将交换机的多个物理端口在逻辑上进行绑定，形成一个具有较高带宽的通道。</p><p><img src="计网实验复习笔记.asset/image-20240519193708182.png" alt="image-20240519193708182" style="zoom:80%;" /></p><h5 id="VLAN的配置与分析"><a href="#VLAN的配置与分析" class="headerlink" title="VLAN的配置与分析"></a>VLAN的配置与分析</h5><p><strong><em>VLAN的产生</em></strong></p><p>为了减少在广播域中转发的报文，将大的广播域隔离成多个较小的广播域，于是出现了VLAN技术。在VLAN技术中，规定凡是具有VLAN功能的<strong>交换机</strong>在转发数据报文时，都需要确认该报文属于某一个VLAN，并且该报文只能被转发到属于同一VLAN的端口或主机，<strong>每个VLAN代表了一个广播域</strong>。（Virtual Local Area Network，虚拟局域网）</p><p><strong><em>VLAN端口的分类</em></strong></p><p>根据端口对VLAN数据帧的处理方式，将交换机的端口氛围Access, Trunk, Hybrid三类。</p><ul><li>Access端口一般指那些<strong>连接不支持VLAN技术的终端设备</strong>的端口，这些端口收到的数据帧都不包含VLAN标签，向外发送数据帧是，也必须保证数据帧中也不包含VLAN标签。一般接主机或路由器。</li><li>Trunk端口一般指那些<strong>连接支持VLAN技术的网络设备</strong>（如交换机）的端口，这些端口接收到的数据帧一般都包含VLAN标签，而向外发送数据帧时，必须保证接收端能够区分不同VLAN的数据帧，故常常需要添加VLAN标签。一般用于交换机之间的连接。</li><li>Hybrid端口属于Access和Trunk的<strong>混合模式</strong>，工作在该模式下的端口可以属于多个VLAN，可以接收和发送多个VLAN报文，可以用于交换机之间连接，也可以用于连接用户的计算机。</li></ul><p><strong><em>VLAN的配置</em></strong></p><ul><li><p>创建/删除VLAN</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[h3c] vlan 2</span><br><span class="line">[h3c] undo vlan 2</span><br></pre></td></tr></table></figure></li><li><p>向当前VLAN中添加/删除端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[h3c-vlan2] port e 1&#x2F;0&#x2F;1</span><br><span class="line">[h3c-vlan2] undo port e 1&#x2F;0&#x2F;1</span><br></pre></td></tr></table></figure></li><li><p>指定端口类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[h3c-Ethernet 1&#x2F;0&#x2F;24] port link-type access | trunk | hybrid</span><br></pre></td></tr></table></figure></li><li><p>指定/删除端口的默认VLAN ID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[h3c-Ethernet 1&#x2F;0&#x2F;1] port trunk pvid vlan 2</span><br><span class="line">[h3c-Ethernet 1&#x2F;0&#x2F;1] undo port hybrid pvid</span><br></pre></td></tr></table></figure></li><li><p>指定/删除Trunk端口可以通过的VLAN数据帧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[h3c-Ethernet 1&#x2F;0&#x2F;24] port trunk permit vlan 2 to 3</span><br></pre></td></tr></table></figure></li><li><p>将Hybrid端口加入到指定的已经存在的VLAN，并标记为tagged或untagged</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[h3c-Ethernet 1&#x2F;0&#x2F;24] port hybrid vlan 30 40 untagged</span><br></pre></td></tr></table></figure></li></ul><p><strong><em>实验要点</em></strong></p><ul><li>先配置基本VLAN，此时两台交换机上相同的VLAN内的主机还不能通信</li><li>配置交换机上的Trunk端口，并允许相应VLAN通过。此时配置为Trunk的接口标记为tagged，表示从该端口通过的报文要打上<code>IEEE 802.1q</code>标记，用于标记该报文所属的VLAN</li><li>这样，当对端交换机收到该报文时，根据tag标记来确定该报文属于哪个VLAN，从而只在该VLAN中广播或单播该报文</li></ul><h5 id="广域网数据链路层协议"><a href="#广域网数据链路层协议" class="headerlink" title="广域网数据链路层协议"></a>广域网数据链路层协议</h5><p>广域网链路层<code>PPP</code>的基本原理和基本配置</p><ul><li><p>配置PPP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[R1] interface s 1&#x2F;0</span><br><span class="line">[R1-serial 1&#x2F;0] link-protocol ppp</span><br><span class="line"># 之后需要shutdown来重启生效</span><br></pre></td></tr></table></figure></li><li><p>配置路由器上PPP的身份验证（PAP, CHAP）</p></li></ul><h4 id="实验三-网络层实验"><a href="#实验三-网络层实验" class="headerlink" title="实验三 网络层实验"></a>实验三 网络层实验</h4><h5 id="ARP分析"><a href="#ARP分析" class="headerlink" title="ARP分析"></a>ARP分析</h5><p>ARP(Address Resolution Protocol)是<strong>地址解析协议</strong>的简称。<strong>地址解析</strong>指的是建立硬件地址与IP地址的映射关系，将IP地址解析成硬件地址。主机存在<strong>ARP缓存</strong>，存放最近的IP地址与硬件地址的对应关系。如果找到相应项，便将报文直接发送出去，否则利用ARP进行解析。</p><ul><li><strong>相同网段：</strong>主机A发送ARP请求报文，主机B收到后，判断报文的目的IP是自己的后，便将自己的硬件地址写入应答报文，发给主机A。主机A收到后将其存入缓存，然后才将报文发往主机B</li><li><strong>不同网段：</strong>主机A将报文<strong>发给自己的默认网关</strong>，请求默认网关的硬件地址同相同网段上的方法。此后默认网关根据目的IP进行转发。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#清空arp缓存</span><br><span class="line">C:\&gt;arp -d</span><br><span class="line">#查看arp缓存</span><br><span class="line">C:\&gt;arp -a</span><br></pre></td></tr></table></figure><p><strong>默认网关：</strong>不同网段下的主机通信，必须经过网关的转发。默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。</p><h5 id="ICMP分析"><a href="#ICMP分析" class="headerlink" title="ICMP分析"></a>ICMP分析</h5><p>ICMP(Internet Control Message Protocol)是<strong>因特网控制报文协议</strong>，允许路由器或主机报告差错情况和提供有关信息。ICMP报文将作为IP数据报的数据，封装在IP数据报中进行传输。可分为ICMP差错报告报文和ICMP询问报文。</p><p>目前网络中常见的基于ICMP的应用程序主要有ping和tracert命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#打开对tracert响应</span><br><span class="line">[S1] ip ttl-expires enable</span><br><span class="line">[S1] ip unreachables enable</span><br></pre></td></tr></table></figure><h5 id="IP分析"><a href="#IP分析" class="headerlink" title="IP分析"></a>IP分析</h5><p>数据报文在网络中的传输主要分为<strong>主机发送和路由器转发</strong>两种。</p><ul><li><strong>主机发送</strong>数据报的方式有<strong>直接交付和间接交付</strong>两种。<ul><li>主机将要发送数据报的目的地址同自己的子网掩码与操作，若结果等于其所在网络地址，则直接交付到本网络</li><li>否则发往下一跳路由器（一般为主机的默认网关）</li></ul></li><li><strong>路由器转发</strong>数据报的方法如下：<ul><li>先判断能否直接交付，不能则查找路由表</li><li>若表中无该目的地址，则通过’’与’’判断是否属于路由表中的网络</li><li>选择具有最长网络前缀的路由表项，将数据报传送给对应的下一跳路由器</li><li>否则报告转发分组出错</li></ul></li></ul><h5 id="网络层分片实验"><a href="#网络层分片实验" class="headerlink" title="网络层分片实验"></a>网络层分片实验</h5><p>由于存在MTU（最大传输单元），有时我们需要将报文分成几片分别传输。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#设置路由器端口MTU</span><br><span class="line">[H3C-Ethernet0&#x2F;0] mtu 100</span><br><span class="line">#设置ping命令数据部分大小</span><br><span class="line">[H3C-Ethernet0&#x2F;0] ping -s 300 192.192.169.21</span><br></pre></td></tr></table></figure><h5 id="VLAN间通信"><a href="#VLAN间通信" class="headerlink" title="VLAN间通信"></a>VLAN间通信</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 清空交换机MAC地址表</span><br><span class="line">[S1] undo mac-address</span><br><span class="line"># 清空三层交换机S1的ARP缓存</span><br><span class="line">&lt;S1&gt; reset arp all</span><br><span class="line"># 清空计算机的ARP缓存</span><br><span class="line">arp -d</span><br></pre></td></tr></table></figure><font color=Red>三层交换机与两层交换机的区别???</font><h4 id="实验四-RIP协议实验"><a href="#实验四-RIP协议实验" class="headerlink" title="实验四 RIP协议实验"></a>实验四 RIP协议实验</h4><h4 id="实验五-OSPF协议分析"><a href="#实验五-OSPF协议分析" class="headerlink" title="实验五 OSPF协议分析"></a>实验五 OSPF协议分析</h4><h5 id="OSPF协议概述及基本配置"><a href="#OSPF协议概述及基本配置" class="headerlink" title="OSPF协议概述及基本配置"></a>OSPF协议概述及基本配置</h5><p><strong><em>OSPF协议概述</em></strong></p><p>OSPF协议是一个<strong>基于链路状态算法</strong>的内部网关协议，OSPF是<strong>开放最短路由优先</strong>(Open Shortest Path First)的缩写。其核心思想是，每一台路由器将其周边的链路状态（包括接口的直连网段、相连的路由器等信息）描述出来，发送给网络中相邻的路由器。经过一段时间的链路状态信息交互，每台路由器都保存了一个<strong>链路状态数据库LSDB</strong>，该数据库是整个网络完整的链路状态描述，在此基础上，应用shortest path first算法就可以计算路由。</p><ol><li><p><strong>自治系统和区域</strong></p><p><strong>自治系统</strong>(Autonomy System)是指由同一机构管理，使用<strong>同一组选路策略</strong>的路由器的集合。它最主要的特点是有权自主地决定在<strong>本系统内采用何种路由选择协议</strong>。</p><p><strong>区域</strong>(Area)指的是一个路由器的集合，相同区域有着相同的拓扑结构数据库。OSPF用区域把一个AS划分成多个链路状态域。区域ID用一个32位整数标识。</p></li><li><p><strong>OSPF的邻居和邻接概念</strong></p><p>OSPF路由器启动后，便会通过OSPF接口向外发送hello报文。收到hello报文的OSPF路由器会检查报文中定义的一些参数，如果双方一直就会形成<strong>邻居关系</strong>。但只有当双方成功交换链路状态通告信息，才形成<strong>邻接关系</strong>。</p></li></ol><p><strong><em>OSPF基本配置</em></strong></p><ol><li><p><strong>配置router id</strong></p><p>如果没有人为指定，路由器会<strong>自动选择</strong>一个接口的IP地址为router id。一般优先选择路由器<strong>回环接口(Loopback)中最大IP地址</strong>，如果没有配置Loopback接口，就选取<strong>物理接口中最大的IP地址</strong>。如果一台路由器的router id在运行中被改变，则<strong>必须重启OSPF协议</strong>或重启路由器才能使其生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system-view</span><br><span class="line">router id (router-id)</span><br><span class="line">undo router id</span><br></pre></td></tr></table></figure></li><li><p><strong>启动OSPF</strong></p><p>OSPF支持多进程，一台路由器上的多个进程由<strong>进程号</strong>区分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ospf [process-id [[router-id router-id] vpn-instance vpn-instance-name]]</span><br><span class="line">undo ospf [process-id]</span><br></pre></td></tr></table></figure></li><li><p><strong>进入OSPF区域视图</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">area (area-id)</span><br><span class="line">undo area (area-id)</span><br></pre></td></tr></table></figure></li><li><p><strong>在指定网段使能OSPF</strong></p><p>启动OSPF后还必须<strong>指定在某个网段上</strong>应用OSPF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">network (ip-address) (wildcard-mask)</span><br><span class="line">undo network (ip-address) (wildcard-mask)</span><br></pre></td></tr></table></figure></li></ol><p><strong><em>OSPF相关命令</em></strong></p><p><img src="计网实验复习笔记.asset/image-20240510094138886.png" alt="image-20240510094138886"></p><h5 id="OSPF协议报文交互过程"><a href="#OSPF协议报文交互过程" class="headerlink" title="OSPF协议报文交互过程"></a>OSPF协议报文交互过程</h5><p><strong><em>OSPF协议报文结构</em></strong></p><ol><li><p>OSPF报文头</p></li><li><p>OSPF协议的可靠传输机制</p><p>OSPF协议基于IP，IP无法提供可靠传输，所以OSPF协议采用了确认和重传机制。</p></li><li><p>OSPF的5种报文类型</p><ol><li><strong>Hello报文</strong>(Hello Packet)：<strong>周期性地发送</strong>给本路由器的邻居</li><li><strong>DD报文</strong>(Database Description Packet)：用于<strong>交换邻居路由器之间链路状态数据库的摘要信息</strong>。分为<strong>空DD报文和带有摘要信息的DD报文</strong>两种，开始时，两个邻居路由器互相发送空DD报文，用来确定<strong>主从关系</strong>，之后才发送带有摘要信息的DD报文。</li><li><strong>LSR报文</strong>(Link State Request Packet)：交换了DD报文后，通过比较能够确认本地链路状态数据库缺少的LSA和需要更新的LSA，需要发送LSR报文<strong>向对方请求所需要LSA</strong>，报文内容包括所需要的<strong>LSA的摘要</strong>。</li><li><strong>LSU报文</strong>(Link State Update Packet)：用来向发送LSR报文的路由器<strong>发送其所需要的LSA</strong>，报文内容是多条LSA的集合。</li><li><strong>LSAck报文</strong>(Link State Acknowledgement Packet)：用来对接收到的LSU报文进<strong>行确认</strong>，报文内容是需要确认的LSA的首部。</li></ol><p>注：LSA为链路状态通告(Link State Advertise)</p></li></ol><p><strong><em>邻居状态机</em></strong></p><p><img src="计网实验复习笔记.asset/image-20240510100959852.png" alt="image-20240510100959852"></p><p><strong><em>OSPF报文交互过程</em></strong></p><ol><li>Hello报文发现邻居</li><li>DD报文的主从关系协商（router id较大的成为主）</li><li>DD报文交换</li><li>LSA请求</li><li>LSA更新</li><li>LSA应答</li></ol><p><img src="计网实验复习笔记.asset/image-20240510102333316.png" alt="image-20240510102333316"></p><h5 id="OSPF协议链路状态描述"><a href="#OSPF协议链路状态描述" class="headerlink" title="OSPF协议链路状态描述"></a>OSPF协议链路状态描述</h5><p><strong><em>OSPF协议的4种网络类型</em></strong></p><ul><li>广播类型：在该类型的网络中，通常以组播形式发送协议报文，选举指定路由器DR和备份指定路由器BDR</li><li>NBMA类型：全连接的非广播多点可达网络NBMA(Non-Broadcast Multi-Access)。以单播形式发送协议报文。手工指定邻居，选举DR和BDR，DR和BDR要求与DRother完全直连</li><li>点到多点PTMP类型：以组播形式发送协议报文。组播Hello报文自动发现邻居，不要求DR/BDR选举</li><li>点到点PTP类型：以组播形式发送协议报文，无需选举DR/BDR</li></ul><p><strong><em>链路状态描述</em></strong></p><p>OSPF协议将路由器周边的网络拓扑结构抽象为4种典型的网络模型，分别为<strong>Stub net、PPP网络、点到多点网络、全连接网络</strong>。对每种类型网络的链路状态描述都可以分为两部分，分别是对<strong>相连网段</strong>的描述和对<strong>相连路由器</strong>的描述。每部分都包括link id, data, type, metric四部分。</p><p><img src="计网实验复习笔记.asset/image-20240510160738227.png" alt="image-20240510160738227"></p><ul><li>Stub net网络描述<ul><li>是指所连接的一个末端网络，该网段没有其他运行OSPF协议的网络设备，只有如计算机这样的设备</li></ul></li><li>PPP网络描述<ul><li>是指通过一条<strong>点到点</strong>的链路<strong>连接另外一台</strong>运行OSPF的路由器</li></ul></li><li>点到多点网络描述<ul><li>是指通过一个<strong>点对多点</strong>的网络<strong>连接另外多台</strong>运行OSPF的路由器，但这些路由器彼此之间并<strong>不是全连通</strong>的</li></ul></li><li>全连接网络描述<ul><li>全连接的网络用第二类LSA描述，其他类型网络用第一类</li></ul></li></ul><p><strong><em>指定路由器DR的选举与第二类LSA</em></strong></p><ol><li><p><strong>指定路由器DR和备份指定路由器BDR</strong></p><p>为了解决全连接网络中N^2连接问题，OSPF协议从该网络中自动选举一台路由器为指定路由器DR，DR路由器负责传递信息。所有路由器都<strong>只将路由信息发送给DR</strong>，再由DR将路由信息发送给本网段内的其他路由器。</p><p>考虑到DR可能失效，为缩短重新选举时间，OSPF提出备份制定路由BDR的方式，他<strong>和DR同时选举出来</strong>，也与该网段内的所有路由器建立邻接关系并交换路由信息。</p><p>这样DRother之间不在建立邻接关系，也不再交换路由信息，只是周期性交换hello报文，邻居状态机停留在<strong>2-way阶段</strong>。</p></li><li><p><strong>DR和BDR的选举过程</strong></p><p>//todo</p></li><li><p><strong>全连接网络描述</strong></p><p>全连接网络是指一个广播或者NBMA网段，该网段中所有运行OSPF协议的网络设备之间都直接相连。</p><p><img src="计网实验复习笔记.asset/image-20240514135124144.png" alt="image-20240514135124144"></p></li></ol><p><strong><em>链路状态通告LSA的结构</em></strong></p><p>//todo</p><p><strong><em>实验要点</em></strong></p><ul><li><p>显示LSA信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R2] display ospf lsdb</span><br></pre></td></tr></table></figure></li><li><p>在路由器上显示第二类LSA信息的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R2] display ospf lsdb network</span><br></pre></td></tr></table></figure></li><li><p>重启OSPF进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reset ospf process</span><br></pre></td></tr></table></figure></li><li><p>显示OSPF调试信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;R1&gt; debugging ospf event</span><br><span class="line">&lt;R1&gt; terminal debugging</span><br></pre></td></tr></table></figure></li></ul><h5 id="区域划分及LSA种类"><a href="#区域划分及LSA种类" class="headerlink" title="区域划分及LSA种类"></a>区域划分及LSA种类</h5><p><strong><em>OSPF协议的区域划分</em></strong></p><p>随着网络规模扩大，LSA(链路状态通告)的集合组成的链路状态数据库(LSDB)会非常庞大，OSPF协议通过划分区域的方式解决。</p><p>区域的边界是路由器，这样<strong>会有一些路由器同时属于不同区域</strong>（ABR，区域边界路由器），但一个网段只能属于一个区域，每个运行OSPF协议的<strong>接口必须明确属于某一个特定的区域</strong>。</p><p>划分区域后，区域内部仍使用第一类和第二类LSA描述区域内网络，并仅限在区域内传播。区域边界路由器收到后，会生成第三类LSA，并传播到相邻的区域。</p><p><strong><em>OSPF与自治系统外部通信</em></strong></p><p>//</p><p><strong><em>LSA种类</em></strong></p><p><img src="计网实验复习笔记.asset/image-20240514141628283.png" alt="image-20240514141628283"></p><p><strong><em>骨干区域与虚连接</em></strong></p><p>Area 0被称为骨干区域</p><h5 id="OSPF协议路由的计算"><a href="#OSPF协议路由的计算" class="headerlink" title="OSPF协议路由的计算"></a>OSPF协议路由的计算</h5><p><strong>6.3.1 SPF算法和Cost值</strong></p><ol><li><p>SPF算法</p><p>SPF算法有时也称为Dijkstra算法，每个路由器根据其上某区域的LSDB，计算出该区域的拓扑结构图，也就是一个加权有向图。SPF算法基于此图，以该路由器为根，计算得到最小生成树，进而获得到每一个目的网段的路由。</p></li><li><p>Cost值</p><p>每一个启动了OSPF的链路都定义了一个Cost值。值越小说明带宽越高，优先级越高。</p></li></ol><p><strong>6.3.2 区域内OSPF路由的计算过程</strong></p><p><img src="计网实验复习笔记.asset/image-20240514142602958.png" alt="image-20240514142602958" style="zoom: 67%;" /></p><p><strong>6.3.3  区域间OSPF路由的计算</strong></p><ol><li>只有同一个区域内的路由器保持LSDB同步</li><li>区域间路由计算通过ABR完成。查询路由表，为每一条OSPF路由生成一条type 3的LSA，发送到另一个区域</li><li>另一个区域内的路由器根据这些LSA生成路由</li></ol><p><strong>6.3.4 区域外OSPF路由的计算</strong></p><p><strong>6.3.5 OSPF路由的类型和优选顺序</strong></p><h5 id="实验要点"><a href="#实验要点" class="headerlink" title="实验要点"></a>实验要点</h5><ul><li><p>在接口上配置Cost的命令</p><ul><li>对于一条线路，两端接口均要进行cost配置</li></ul><p><img src="计网实验复习笔记.asset/image-20240514143530064.png" alt="image-20240514143530064" style="zoom: 80%;" /></p></li><li><p>验证路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1] tracert 10.1.1.2</span><br></pre></td></tr></table></figure></li></ul><h4 id="实验六-BGP协议实验"><a href="#实验六-BGP协议实验" class="headerlink" title="实验六 BGP协议实验"></a>实验六 BGP协议实验</h4><h5 id="BGP的基本分析"><a href="#BGP的基本分析" class="headerlink" title="BGP的基本分析"></a>BGP的基本分析</h5><p>BGP的基本功能是在自治系统间自动交换无环路的路由信息</p><p><strong>2.3.3 BGP的工作机制</strong></p><p>发送BGP报文的路由器称为BGP<strong>发言人</strong>(Speaker)，与他交换路由信息的其他BGP发言人称为<strong>对等体</strong>(Peer)，若干相关对等体可以构成<strong>对等体组</strong>(Group)。BGP发言人不断接收或产生新路由信息，并将它<strong>通告</strong>(Advertise)给其他BGP发言人。</p><p>对于一个自治系统边界路由器(ASBR)，路由的来源有两种，BGP发送优选的BGP路由和引入的IGP路由给对等体：</p><ul><li><strong>对等体接收</strong>：根据其属性进行过滤，根据规则选择最好的路由加入IP路由表</li><li><strong>IGP引入</strong>：要经过引入策略的过滤</li></ul><p>BGP在路由器上以EBGP和IBGP两种方式运行：</p><ul><li><strong>EBGP</strong>：属于不同AS的交换报文</li><li><strong>IBGP</strong>：对等体属于同一个AS，IBGP对等体之间不一定是物理直连，但要保证能够建立TCP连接</li></ul><p><strong>2.3.4 BGP路由通告原则</strong></p><ol><li>到达同一目的网络存在多条路径时，选择最优的</li><li>只把自己使用的路由通告给对等体</li><li>从EBGP获得的路由向所有BGP对等体通告</li><li>从IBGP获得的路由不会向IBGP对等体通告</li><li>从IBGP获得的路由是否通告给EBGP对等体要根据IGP和BGP<strong>同步情况</strong>决定</li><li>连接建立，发言人立即将自己所有BGP路由通告给新对等体</li></ol><p><strong>2.3.5 如何成为BGP路由</strong></p><p>BGP的主要工作是在AS间传递路由，而不是发现和计算路由。后者有IGP(OSPF)完成。BGP的路由信息需要通过配置命令的方式注入BGP中。</p><ul><li>纯动态注入：路由器将通过IGP获得的路由信息直接注入BGP，不进行过滤和选择</li><li>半动态注入：路由器有选择地将IGP发现的路由信息注入BGP</li><li>静态注入：路由器将静态配置的某条路由注入BGP</li></ul><p><strong>2.3.6 BGP的报文结构</strong></p><p>OPEN报文用于建立邻居关系，其他对等体收到后，立即以KEEPALIVE报文作响应。握手成功后，BGP邻居可以进行UPDATE, KEEPALIVE以及NOTIFICATION等报文的交互操作。</p><ul><li><strong>OPEN</strong><ul><li>对等体间通过发送OPEN报文交换各自版本、AS号等信息，<strong>进行协商</strong></li></ul></li><li><strong>UPDATE</strong><ul><li>UPDATE报文携带<strong>路由更新信息</strong>，包括撤销路由信息和可达路由信息及其路径属性</li><li>最多由三部分组成：<ul><li>不可达路由</li><li>路径属性</li><li>网络可达性信息</li></ul></li></ul></li><li><p><strong>NOTIFICATION</strong></p><ul><li>检测到差错时，发送NOTIFICATION报文，<strong>关闭同对等体的连接</strong></li></ul></li><li><p><strong>KEEPALIVE</strong></p><ul><li>在BGP对等体间周期性地发送，以<strong>确保连接保持有效</strong></li></ul></li></ul><p><strong>实验要点</strong></p><ul><li><p>启动BGP，加入对等体</p><ul><li><strong>对于IBGP需要强制下一跳为</strong></li></ul><p><img src="计网实验复习笔记.asset/image-20240514151027648.png" alt="image-20240514151027648"></p></li><li><p>注入路由信息</p><p><img src="计网实验复习笔记.asset/image-20240514151139557.png" alt="image-20240514151139557"></p></li><li><p>指定源地址的ping操作</p><p><img src="计网实验复习笔记.asset/image-20240514151212655.png" alt="image-20240514151212655"></p></li><li><p>取消BGP协议配置</p><ul><li>undo bgp</li></ul></li></ul><h5 id="BGP状态机的分析"><a href="#BGP状态机的分析" class="headerlink" title="BGP状态机的分析"></a>BGP状态机的分析</h5><p><img src="计网实验复习笔记.asset/image-20240514151506991.png" alt="image-20240514151506991" style="zoom:80%;" /></p><ul><li><p>获取debug信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;R1&gt; debug bgp event</span><br><span class="line">&lt;R1&gt; terminal debugging</span><br><span class="line">&lt;R1&gt; reset bgp all</span><br></pre></td></tr></table></figure></li></ul><h5 id="BGP的路由聚合"><a href="#BGP的路由聚合" class="headerlink" title="BGP的路由聚合"></a>BGP的路由聚合</h5><p>路由聚合使得路由表中一个项目能够表示多个传统分类地址的路由，减少维护数目。</p><p><img src="计网实验复习笔记.asset/image-20240514151855214.png" alt="image-20240514151855214"></p><p><img src="计网实验复习笔记.asset/image-20240514151904328.png" alt="image-20240514151904328" style="zoom:80%;" /></p><h5 id="BGP的基本路由属性分析"><a href="#BGP的基本路由属性分析" class="headerlink" title="BGP的基本路由属性分析"></a>BGP的基本路由属性分析</h5><p><strong>5.3.2 常见的BGP路由属性</strong></p><ul><li>origin：<ul><li>0： IGP</li><li>1： EGP</li><li>2： 其他</li><li><img src="计网实验复习笔记.asset/image-20240516194516120.png" alt="image-20240516194516120" style="zoom:80%;" /></li></ul></li><li>as-path：<ul><li>避免环路</li><li>影响路径选择</li></ul></li><li><strong>next-hop：</strong><ul><li>BGP向IBGP通告从其他EBGP获得的路由时，不改变下一跳属性</li><li>BGP向EBGP通告路由时，下一跳是本地BGP与对端连接的端口地址</li><li>对于可以多路访问的网络</li></ul></li><li>MED：<ul><li>用于向外部邻居路由器指示进入某个具有多个入口的AS的优先路径，MED较小的优先</li></ul></li><li>local-preference（本地优先级）：<ul><li>用于帮助AS内部的路由器选择到外部的较好出口，值越大优先级越高</li></ul></li></ul><p><strong>5.5 实验要点</strong></p><ul><li><p>引入路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import-route protocol [ process-id ] [ med med | route-policy route-policy-name ]</span><br><span class="line">undo import-route protocol [ process-id ]</span><br><span class="line">#例如，引入直连路由</span><br><span class="line">[s1-bgp] import-route direct</span><br></pre></td></tr></table></figure></li><li><p>显示bgp路由表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[s1-bgp] display bgp routing-table</span><br></pre></td></tr></table></figure></li></ul><h5 id="BGP的路由策略"><a href="#BGP的路由策略" class="headerlink" title="BGP的路由策略"></a>BGP的路由策略</h5><p>BGP是在自治系统之间交换路由信息的，由于各种原因，BGP需要对发送和接收的路由信息进行<strong>过滤</strong>，也就是<strong>实施路由策略</strong>。路由策略是提供给路由协议<strong>实现信息过滤</strong>的手段。</p><ul><li>路由协议在与对端路由器进行路由信息交换时，可能需要只接收或发布一部分满足给定条件的路由信息。</li><li>路由协议（如OSPF）在引入其他路由协议（如BGP）的路由信息时，可能需要只引入一部分满足条件的路由信息，并对所引入的路由信息的某些属性进行设定以满足本协议的要求。</li></ul><p>路由策略一般由一系列的规则组成，这些规则大体上分为3类，分别作用于：路由发布、路由接收和路由引入。与路由策略相关的过滤器通常有：</p><ul><li><p><strong>访问控制列表（ACL）</strong>：</p><ul><li><p>定义路由器过滤数据包的规则</p></li><li><p>是由permit | deny语句组成的<strong>有顺序</strong>规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看规则</span><br><span class="line">display acl</span><br></pre></td></tr></table></figure></li><li><p><img src="计网实验复习笔记.asset/image-20240514185020245.png" alt="image-20240514185020245" style="zoom:80%;" /></p></li></ul></li><li><p><strong>自治系统路径信息访问列表（AS-Path List）</strong>：</p><ul><li>指定BGP从对等体输入或向对等体输出路由信息时，过滤含有指定AS路径属性的路由</li></ul></li><li><p><img src="计网实验复习笔记.asset/image-20240514184132296.png" alt="image-20240514184132296" style="zoom:80%;" /></p></li><li><p><img src="计网实验复习笔记.asset/image-20240514184844264.png" alt="image-20240514184844264" style="zoom:80%;" /></p><ul><li><p><strong>路由策略：</strong></p><ul><li>每个路由策略可以有若干规则，用节点号标识。按节点号从小到大的顺序进行匹配，遇到第一个匹配的规则，就完成此次路由策略过程。</li><li><img src="计网实验复习笔记.asset/image-20240514184431671.png" alt="image-20240514184431671" style="zoom:80%;" /></li><li>复位BGP： reset bgp {all | peer-id}</li></ul></li></ul></li></ul><p><strong>6.4 实验要点</strong></p><ul><li>配置<strong>基于ACL</strong>的路由过滤<ul><li><img src="计网实验复习笔记.asset/image-20240514184725031.png" alt="image-20240514184725031" style="zoom:80%;" /></li></ul></li><li>配置<strong>基于As-Path</strong>的路由过滤<ul><li><img src="计网实验复习笔记.asset/image-20240514185240957.png" alt="image-20240514185240957" style="zoom:80%;" /></li></ul></li><li>配置<strong>基于Route Policy</strong>的路由过滤<ul><li><img src="计网实验复习笔记.asset/image-20240514185617504.png" alt="image-20240514185617504" style="zoom:80%;" /></li></ul></li></ul><h5 id="BGP的同步机制"><a href="#BGP的同步机制" class="headerlink" title="BGP的同步机制"></a>BGP的同步机制</h5><p>BGP规定：一个BGP路由器不能将从IBGP对等体得知的路由信息通告给EBGP，除非该路由信息也能通过IGP得知，这就是<strong>同步机制</strong>。同步机制避免了通告路由但实际不可达的情况。</p><p><strong>解决方式</strong>：</p><ol><li><p>把从外部得到的BGP路由引入IGP中</p></li><li><p>在AS内相应路由器上配置静态路由</p></li></ol><p><em>注意下一跳中的端口地址是对等体的端口，而不是自己的端口</em></p><h4 id="实验七-传输层实验"><a href="#实验七-传输层实验" class="headerlink" title="实验七 传输层实验"></a>实验七 传输层实验</h4><p>主要有TCP和UDP两种传输协议。</p><h5 id="TCP基本分析"><a href="#TCP基本分析" class="headerlink" title="TCP基本分析"></a>TCP基本分析</h5><ul><li>TCP(Transfer Control Protocol)是传输控制协议的简称。TCP工作在网络层协议之上，是一个<strong>面向连接的、端到端的、可靠的</strong>传输层协议。</li><li>TCP采用运输连接的方式传送TCP报文，包括连接建立、数据传送和连接释放三个阶段。</li></ul><p><strong><em>1. TCP连接的建立</em></strong></p><p>采用3次握手方式（A主动打开，B被动打开）：</p><ul><li>主机A向主机B发出连接请求报文段，<strong>SYN置1</strong>，选择一个序号x（表明在之后传送数据时第一个数据字节的序号为x+1）</li><li>主机B收到连接请求报文后，若同意，则发回确认。<strong>SYN和ACK都置1</strong>，确认号为x+1，为自己选择一个序号y</li><li>最后主机A收到B的确认后，要向B给出确认，<strong>ACK置1</strong>，确认号为y+1，自己的序号为x+1</li></ul><p><strong><em>2. TCP数据的传送</em></strong></p><p>为保证TCP传输可靠性，采用<strong>面向字节</strong>的方式，每个字节对应一个序号。<strong>序号字段</strong>可以确认发送方传送数据的每一个字节的序号，<strong>确认号字段</strong>则表示接收方在此之前的数据字节均已收到。这样几做到了可靠传输，又做到了全双工通信。</p><p><strong><em>3. TCP连接的释放</em></strong></p><p>TCP连接的释放采用4次握手方式：</p><ul><li>主机A向主机B发出释放请求，且不再发送数据，<strong>FIN置1</strong>，其序号x等于前面已传过的数据的最后一个字节的序号加1(x+1)</li><li>主机B收到后发出确认，序号为y，确认号为x+1，同时通知高层应用进程。此时A到B的连接已释放，相当于“A没有数据发送了，但仍接收B发送的数据”</li><li>若主机B不再向主机A发送数据，则终止比特<strong>FIN和确认比特ACK置1</strong>，并使序号仍为y，重复上次发过的ACK=x+1</li><li>主机A需要发出确认，<strong>ACK置1</strong>，ACK=y+1，序号为x+1</li></ul><h5 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h5><p><strong><em>TCP的滑动窗口机制</em></strong></p><p>TCP采用大小可变的滑动窗口进行流量控制。</p><p>发送端设置的当前能够发送的数据量大小叫做<strong>发送窗口</strong>，上限值为cwnd和rwnd的较小值。</p><ul><li><p><strong>发送窗口</strong>在连接建立时由双方商定，但接收端可根据自己的接收缓存的大小，动态调整发送端的发送窗口的上限值。这就是<strong>接收端窗口</strong>rwnd，被放在接收端发送的<strong>TCP报文段首部的窗口字段</strong>中。</p></li><li><p>同时，发送端根据其对当前网络拥塞程度的估计而确定的窗口值，叫做<strong>拥塞窗口</strong>cwnd，其大小与网络的带宽和时延密切相关。</p></li></ul><p><em>窗口合拢、窗口张开、窗口收缩</em></p><p><strong><em>TCP的慢启动和拥塞避免</em></strong></p><p>慢启动和拥塞避免分别是<strong>指数增长和线性增长</strong></p><p>设置慢启动门限ssthresh(slow start thresh)，超过门限则使用拥塞避免算法，否则为慢启动</p><p><strong><em>网络拥塞的处理</em></strong></p><p>网络拥塞是指发送端没有按时收到确认报文或者收到了重复的确认报文。发送端发现网络拥塞，重新设置慢启动门限：ssthresh=max(cwnd/2, 2*MSS(报文段最大长度))，以及cwnd=1</p><p><strong><em>TCP的超时与重传</em></strong></p><p>超时重传时间应略大于平均往返时延RTT</p><p><strong><em>TCP的窗口探查技术</em></strong></p><p>当接收端缓存已满，则向发送端发送一个窗口为0的通告报文。发送端收到后，停止发送报文，等待新的窗口通告。为了避免出现死锁，发送方使用一个坚持定时器<strong>周期性向接收方查询</strong>，以便发现窗口是否增大。</p><p><strong><em>TCP的快重传和快恢复</em></strong></p><p><strong><em>实验要点</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在路由器上配置端口转发速率为10Mbps</span><br><span class="line">[R1]interface e0&#x2F;0</span><br><span class="line">[R1-Ethernet0&#x2F;0]qos lr outbound cir 10000</span><br></pre></td></tr></table></figure><h5 id="UDP分析"><a href="#UDP分析" class="headerlink" title="UDP分析"></a>UDP分析</h5><p>UDP(User Datagram Protocol)主要用来支持在计算机之间传输数据的网络应用，UDP报文封装在IP报文中传输。UDP是不可靠的，在传输数据之前不建立连接，传输过程中没有报文确认信息。</p><h4 id="实验七-应用层实验"><a href="#实验七-应用层实验" class="headerlink" title="实验七 应用层实验"></a>实验七 应用层实验</h4><h5 id="DNS协议分析"><a href="#DNS协议分析" class="headerlink" title="DNS协议分析"></a>DNS协议分析</h5><p>DNS是域名系统(Domain Name System)的缩写，主要用来将主机名和电子邮件目标地址映射成IP地址。</p><h5 id="HTTP分析"><a href="#HTTP分析" class="headerlink" title="HTTP分析"></a>HTTP分析</h5><h5 id="SMTP分析"><a href="#SMTP分析" class="headerlink" title="SMTP分析"></a>SMTP分析</h5><h5 id="FTP分析"><a href="#FTP分析" class="headerlink" title="FTP分析"></a>FTP分析</h5><h5 id="DHCP分析"><a href="#DHCP分析" class="headerlink" title="DHCP分析"></a>DHCP分析</h5><h4 id="实验八-综合组网实验"><a href="#实验八-综合组网实验" class="headerlink" title="实验八 综合组网实验"></a>实验八 综合组网实验</h4><h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><h5 id="1-什么时候用反掩码"><a href="#1-什么时候用反掩码" class="headerlink" title="1. 什么时候用反掩码"></a>1. 什么时候用反掩码</h5><ul><li><p>路由策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1-acl-2001]rule permit source 10.0.0.0 0.0.0.255</span><br></pre></td></tr></table></figure></li><li><p>OSPF路由注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[S1-ospf-area-0.0.0.0] network 30.1.1.0 0.0.0.255</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-缺省路由"><a href="#2-缺省路由" class="headerlink" title="2. 缺省路由"></a>2. 缺省路由</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route-static 0.0.0.0 0.0.0.0 next-hop</span><br></pre></td></tr></table></figure><h5 id="3-OSPF常见路由注入方式"><a href="#3-OSPF常见路由注入方式" class="headerlink" title="3. OSPF常见路由注入方式"></a>3. OSPF常见路由注入方式</h5><ul><li>network ip地址 <strong>反掩码</strong> </li><li>import-route direct</li><li>import-route static</li></ul><h5 id="4-BGP常见路由注入方式"><a href="#4-BGP常见路由注入方式" class="headerlink" title="4. BGP常见路由注入方式"></a>4. BGP常见路由注入方式</h5><ul><li>network ip地址 <strong>掩码</strong> </li><li>import-route direct</li><li>import-route static</li></ul><h5 id="5-PPP协议启动"><a href="#5-PPP协议启动" class="headerlink" title="5. PPP协议启动"></a>5. PPP协议启动</h5><p>PPP协议配置后，需要先shutdown再undo来重新启动端口，使协议生效</p><h5 id="6-启动debug信息指令汇总"><a href="#6-启动debug信息指令汇总" class="headerlink" title="6. 启动debug信息指令汇总"></a>6. 启动debug信息指令汇总</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ospf</span><br><span class="line">&lt;R1&gt;debugging ospf event</span><br><span class="line">&lt;R1&gt;dterminal debugging</span><br><span class="line"># bgp</span><br><span class="line">&lt;R1&gt;debug bgp event</span><br><span class="line">&lt;R1&gt;terminal debugging</span><br><span class="line"># ppp</span><br><span class="line">&lt;R1&gt;debugging ppp all &#x2F;&#x2F; 打开PPP的debug开关</span><br><span class="line">&lt;R1&gt;terminal debugging &#x2F;&#x2F; 显示debug信息</span><br><span class="line"># PAP</span><br><span class="line">&lt;R1&gt;debugging ppp pap all</span><br><span class="line">&lt;R1&gt;terminal debugging</span><br></pre></td></tr></table></figure><h5 id="7-网络实验常见问题解答"><a href="#7-网络实验常见问题解答" class="headerlink" title="7. 网络实验常见问题解答"></a>7. 网络实验常见问题解答</h5><ol><li><p>v5 和 v7 版本指令差异：</p><ul><li>访问控制列表配置：<ul><li>v5: acl number 2001</li><li>v7: acl basic 2001</li></ul></li><li>NAT地址转换：<ul><li>v5: nat address-group 1 192.168.5.105 192.168.5.109</li><li>v7: nat address-group 1; address 192.168.5.105 192.168.5.109</li></ul></li></ul></li><li><p>PC机无法抓到<code>IEEE802.3</code>格式报文</p><ul><li>在本地属性中选择安装<code>NWLink IPX/SPX/NETBIOS协议</code></li><li><code>IEEE802.3</code>是MAC帧结构的标准</li><li><code>IEEE802.1Q</code>是vlan tag</li></ul></li><li><p>接口不停up和down</p><ol><li>线缆接触不良</li><li>两个接口的有关协议自动协商不成功，需要将一方shutdown，配置完再undo</li></ol></li><li><p>quit和return命令</p><ol><li>quit：回到上一级视图</li><li>return：直接回到用户视图</li></ol></li><li><p>debugging信息停不下来</p><ol><li>使用快捷键<code>&lt;ctrl+O&gt;</code></li><li>输入若干次quit+回车</li></ol></li><li><p>PPP实验的Serial接口问题</p><ol><li>避免s2/0接口的干扰，先将其shutdown</li></ol></li><li><p>PAP认证问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#情况1</span><br><span class="line">[R1] local-user RTB class network</span><br><span class="line">[R10luser-network-RTB] service-type ppp</span><br><span class="line"></span><br><span class="line">#情况2</span><br><span class="line">[R2] local-user RTA</span><br><span class="line">[R2-luser-RTA]service-type ppp</span><br><span class="line">[P2-luser-RTA]password simple aaa</span><br></pre></td></tr></table></figure></li><li><p>请求失败</p><ol><li>以管理员身份运行</li></ol></li><li><p>tracert -d 避免DNS干扰</p></li><li><p>小心出厂配置干扰</p><p>[h3c]undo interface vlan 1</p></li><li><p>BGP上的v7指令</p><ol><li><p>BGP基本配置</p></li><li><p>查看BGP邻居状态</p><p>display bgp peer ipv4</p></li><li><p>查看BGP路由</p><p>display bgp routing-table ipv4</p></li><li><p>路由聚合</p></li></ol></li><li><p>BGP default med命令不生效</p><p>采用路由策略配置：</p><p><img src="计网实验复习笔记.asset/image-20240520145845941.png" alt="image-20240520145845941"></p></li><li><p>TCP的seq number都是相对序号</p><p><code>wireshark, edit-&gt;preference-&gt;tcp-&gt;取消勾选relative seq number</code></p></li><li><p>TCP捎带确认</p><p>四次握手会合并为三次</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[BUAA Software Engineering] Notes</title>
      <link href="/2024/06/11/%E8%BD%AF%E5%B7%A5LOG%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/06/11/%E8%BD%AF%E5%B7%A5LOG%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Pinia：状态管理"><a href="#Pinia：状态管理" class="headerlink" title="Pinia：状态管理"></a>Pinia：状态管理</h2><blockquote><p>是vue生态中vuex的替代者</p></blockquote><h3 id="主要优势"><a href="#主要优势" class="headerlink" title="主要优势"></a>主要优势</h3><ul><li><p>对vue2和vue3很好地支持</p></li><li><p>只有state, getters, actions，极大地简化了状态管理库的使用</p></li><li><p>不需要嵌套模块</p></li><li><p>完整的TypeScript支持，vuex对TS的语法支持不完整</p><blockquote><p>TypeScript是JavaScript的超集，覆盖全部元素</p></blockquote></li><li><p>代码更简洁，实现代码自动分割</p></li></ul><h3 id="创建store"><a href="#创建store" class="headerlink" title="创建store"></a>创建store</h3><h4 id="在main-js里引入pinia"><a href="#在main-js里引入pinia" class="headerlink" title="在main.js里引入pinia"></a>在main.js里引入pinia</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createPinia &#125; from &#39;pinia&#39;</span><br></pre></td></tr></table></figure><p>引入后，通过createPinia()得到实例，将其挂载到Vue根实例上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># main.js</span><br><span class="line"><span class="keyword">import</span> &#123;createApp&#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createPinia&#125; <span class="keyword">from</span> <span class="string">'pinia'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建pinia实例</span></span><br><span class="line"><span class="keyword">const</span> pinia = createPinia()</span><br><span class="line"><span class="keyword">const</span> app = createApp()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载到vue根实例上</span></span><br><span class="line">app.use(pinia)</span><br><span class="line">app.mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><h4 id="创建store状态管理库"><a href="#创建store状态管理库" class="headerlink" title="创建store状态管理库"></a>创建store状态管理库</h4><p>在/src目录下新建一个store文件夹，在里面创建一个index.js文件，然后在其中进行：</p><ul><li><p>定义状态容器（仓库）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore&#125; <span class="keyword">from</span> <span class="string">'pinia'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mainStore = defineStore(<span class="string">'main'</span>,&#123;</span><br><span class="line">  state:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters:&#123;&#125;,</span><br><span class="line">  actions:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>defineStore()的第一个参数：给容器起名</li><li>defingStore()的第二个参数：配置对象，对容器的配置说明</li><li>state属性：存储全局状态</li><li>getters属性：监听状态变化，有缓存功能</li><li>actions属性：对state中数据变化的业务逻辑，相当于修改state全局状态数据</li></ul></li><li><p>定义容器中的state</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">state:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     helloPinia:<span class="string">'Hello Pinia!'</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这样helloPinia就是全局的状态数据，每个页面和组件都可以通过Pinia方法读取到</p></li></ul><h4 id="在vue3组件里读取store数据"><a href="#在vue3组件里读取store数据" class="headerlink" title="在vue3组件里读取store数据"></a>在vue3组件里读取store数据</h4><p>先引入mainStore，然后通过mainStore得到store实例，就可以在组件里调用store里state定义的状态数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;h2 class&#x3D;&quot;&quot;&gt;&#123;&#123; store.helloPinia&#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">import &#123; mainStore &#125; from &quot;..&#x2F;store&#x2F;index&quot;;</span><br><span class="line">export default&#123;</span><br><span class="line">  setup()&#123;</span><br><span class="line">      const store &#x3D; mainStore();</span><br><span class="line">      </span><br><span class="line">      return&#123;</span><br><span class="line">          store,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="Pinia改变状态数据和注意事项"><a href="#Pinia改变状态数据和注意事项" class="headerlink" title="Pinia改变状态数据和注意事项"></a>Pinia改变状态数据和注意事项</h4><h4 id="Pinia修改状态数据的多种方法"><a href="#Pinia修改状态数据的多种方法" class="headerlink" title="Pinia修改状态数据的多种方法"></a>Pinia修改状态数据的多种方法</h4><ul><li>调用组件中使用方法直接修改</li><li>使用$patch修改多条数据<ul><li>不是必须的</li><li>但是会加快修改速度</li></ul></li><li>在actions中写好逻辑，调用actions</li></ul><h4 id="Pinia中Getters使用"><a href="#Pinia中Getters使用" class="headerlink" title="Pinia中Getters使用"></a>Pinia中Getters使用</h4><ul><li>新增状态属性和编写Getters<ul><li>在state中增加一个Phone状态数据，在getters里编写一个方法用于隐藏手机号中间四位，在页面中通过store.phoneHidden调用显示隐藏号码</li></ul></li><li>Getters的缓存特性<ul><li>虽然调用多次，但值一样就不会被多次调用</li></ul></li></ul><h4 id="Pinia中Store的互相调用"><a href="#Pinia中Store的互相调用" class="headerlink" title="Pinia中Store的互相调用"></a>Pinia中Store的互相调用</h4><blockquote><p>真实项目中往往存在多个Store，会涉及到内部相互调用的问题</p></blockquote><p>直接在index1.js中引入index2.js包含的store2，然后调用方法即可：store2().list()</p><h2 id="前端打包"><a href="#前端打包" class="headerlink" title="前端打包"></a>前端打包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>前端打包是指将多个模块、库、资源文件等组合成一个或多个输出文件的过程</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>减少HTTP请求数量</li><li>优化代码：打包工具通常提供代码压缩、去除未使用代码（Tree Shaking）等功能，可以减小文件大小</li><li>模块解析：打包工具处理模块之间的额依赖关系，确保代码的正确加载和执行顺序</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>使用webpack作为打包工具</p><p>配置Webpack（webpack.config.js）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>, <span class="comment">// 入口文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>, <span class="comment">// 打包后的文件名</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>) <span class="comment">// 输出路径</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">'production'</span> <span class="comment">// 生产模式，会进行代码优化等操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>执行打包命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack --config webpack.config.js</span><br></pre></td></tr></table></figure><h2 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>代码分割是一种将代码拆分成多个独立块（chunk）的技术，以便按需加载或并行加载。这可以提高应用程序的加载性能</p><h3 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h3><ul><li>按需加载：通过将代码分割成不同的块，可以根据用户需要只加载必要的代码，而不是一次性加载整个应用程序</li><li>提高性能：通过并行加载多个较小的代码块，可以更快地加载应用程序，减少用户的等待时间</li><li>缓存效率：当应用程序的某部分更新时，只需重新加载更改的代码块，而不是整个应用程序，这提高了缓存效率</li></ul><h2 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h2><h3 id="什么是打包工具"><a href="#什么是打包工具" class="headerlink" title="什么是打包工具"></a>什么是打包工具</h3><ul><li>WebPack是一个前端模块化<strong>方案</strong>，侧重模块打包，把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源，Gulp也可以配置seajs、requirejs甚至webpack的插件</li><li>它会分析你的项目结构，找到JS模块以及那些浏览器不能够直接运行的扩展语言（如：TypeScript等），然后将其转换和打包为合适的格式供浏览器使用。<strong>它最大的优点就是“模块化”（万物皆模块）</strong></li></ul><h4 id="1-代码模块化和依赖管理"><a href="#1-代码模块化和依赖管理" class="headerlink" title="1. 代码模块化和依赖管理"></a>1. 代码模块化和依赖管理</h4><p>现代 JavaScript 应用通常由许多小的模块组成，每个模块负责不同的功能。</p><ul><li><p><strong>模块化开发</strong>：将代码拆分成多个模块，可以提高代码的可维护性和可读性。</p></li><li><p><strong>依赖管理</strong>：前端打包工具（如 Webpack、Vite 等）能够自动解析模块间的依赖关系，确保正确的加载顺序。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; hello &#125; <span class="keyword">from</span> <span class="string">'./hello.js'</span>;</span><br><span class="line">hello();</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, World!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包工具会自动处理这些模块的依赖关系，并将它们打包成一个单独的文件。</p></li></ul><h4 id="2-文件优化和性能提升"><a href="#2-文件优化和性能提升" class="headerlink" title="2. 文件优化和性能提升"></a>2. 文件优化和性能提升</h4><p>前端应用常常包含大量的静态资源，如 JavaScript、CSS、图片等。打包工具可以对这些资源进行优化，从而提升性能。</p><ul><li><p><strong>代码压缩（Minification）</strong>：打包工具可以删除代码中的空白字符、注释、未使用的代码等，减少文件大小。</p></li><li><p><strong>代码混淆（Obfuscation）</strong>：混淆代码以提高代码的难读性，增加代码安全性。</p></li><li><p><strong>代码分割（Code Splitting）</strong>：将应用分割成多个小包，按需加载，减少初始加载时间。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打包前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">longFunctionName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">"Hello, World!"</span>)&#125;</span><br></pre></td></tr></table></figure><p>通过压缩和混淆，可以显著减小文件大小。</p></li></ul><h4 id="3-提供开发工具和增强开发体验"><a href="#3-提供开发工具和增强开发体验" class="headerlink" title="3. 提供开发工具和增强开发体验"></a>3. 提供开发工具和增强开发体验</h4><p>打包工具通常集成了许多开发者友好的工具和功能，使开发过程更加高效。</p><ul><li><p><strong>实时重载（Hot Module Replacement, HMR）</strong>：在开发时，代码改变后，自动刷新页面或更新模块，而无需手动刷新。</p></li><li><p><strong>本地开发服务器</strong>：提供本地开发服务器，模拟真实环境进行开发。</p></li><li><p><strong>代码转换（Transpiling）</strong>：将现代 JavaScript（如 ES6+）或其他语言（如 TypeScript）转换成浏览器兼容的版本。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 ES6 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; greet &#125; <span class="keyword">from</span> <span class="string">'./greet.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// greet.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> greet = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Hello, modern JavaScript!'</span>);</span><br></pre></td></tr></table></figure><p>打包工具会将这些 ES6 模块转换成 ES5 或更低版本，以兼容较旧的浏览器。</p></li></ul><h4 id="4-多种文件类型支持和预处理"><a href="#4-多种文件类型支持和预处理" class="headerlink" title="4. 多种文件类型支持和预处理"></a>4. 多种文件类型支持和预处理</h4><p>现代前端项目通常使用多种文件类型，打包工具可以处理和转换这些文件。</p><ul><li><p><strong>CSS 预处理</strong>：支持 SASS、LESS 等预处理器，允许在 CSS 中使用变量、嵌套等高级功能。</p></li><li><p><strong>图像和字体处理</strong>：优化和打包图像、字体等静态资源。</p></li><li><p><strong>构建工具集成</strong>：集成 Babel、PostCSS 等工具，提供更多功能和灵活性。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SASS 文件</span></span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span>;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打包工具会将 SASS 文件编译成标准的 CSS 文件。</p></li></ul><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><ul><li><strong>优点：</strong><ul><li>灵活的配置选项，满足复杂的项目需求</li><li>插件和加载器生态系统丰富</li><li>支持代码拆分、懒加载、文件压缩等优化</li><li>可以通过插件和加载器来扩展和定制Webpack的功能</li></ul></li><li><strong>缺点：</strong><ul><li>学习曲线较陡峭</li><li>配置相对复杂</li></ul></li></ul><h3 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h3><h4 id="依赖预构建的目的"><a href="#依赖预构建的目的" class="headerlink" title="依赖预构建的目的"></a>依赖预构建的目的</h4><ul><li><strong>CommonJs和UMD的兼容性：</strong>在开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将以 CommonJS 或 UMD 形式提供的依赖项转换为 ES 模块。</li><li><strong>性能：</strong>为了提高后续页面的加载性能，Vite将那些具有许多内部模块的 ESM 依赖项转换为单个模块。<font color="Red">（ESM是ES6模块的简称）</font></li></ul><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>Vite通过利用浏览器<strong>原生的ES模块导入</strong>，提供了快速的开发体验和构建过程</li><li>支持最新的前端技术</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>相对较新的工具，可能存在一些稳定性和兼容性问题</li></ul><h3 id="webpack和vite对比"><a href="#webpack和vite对比" class="headerlink" title="webpack和vite对比"></a>webpack和vite对比</h3><h4 id="核心概念—bundle与否"><a href="#核心概念—bundle与否" class="headerlink" title="核心概念—bundle与否"></a>核心概念—bundle与否</h4><ul><li>webpack使用Node.js编写的打包器从入口开始逐步构建依赖图，然后将项目中所需的模块组合成一个或多个bundle文件</li><li>vite无需进行bundle操作，源文件之间的依赖关系通过浏览器对ESM规范的支持来解析，将应用中的模块区分为依赖(node_modules)和源码(项目代码)两类<ul><li>依赖（node_modules）：使用esbuild预构建，esbuild使用go语言编写，比node.js编写的打包器与构建依赖快10-100倍</li><li>源码：在浏览器请求时按需转换并以元素ESM的方式提供源码，让浏览器接管了打包工具的部分工作</li></ul></li></ul><h4 id="首屏、懒加载性能"><a href="#首屏、懒加载性能" class="headerlink" title="首屏、懒加载性能"></a>首屏、懒加载性能</h4><ul><li>webpack经过漫长的bundle过程，得到了完整的模块关系依赖包，不存在这个问题</li><li>vite由于unbundle机制，在这方面存在问题<ul><li>未对源文件进行合并捆绑操作，导致大量http请求产生</li><li>预构建、二次构建操作也会阻塞首屏请求</li></ul></li></ul><h4 id="服务器启动速度"><a href="#服务器启动速度" class="headerlink" title="服务器启动速度"></a>服务器启动速度</h4><ul><li>webpack需要先把所有的模块建立依赖关系打包成一个大文件，速度相对较慢</li><li>vite将模块分为依赖和源码两部分进行预构建，快很多</li></ul><h2 id="Ajax和Axios"><a href="#Ajax和Axios" class="headerlink" title="Ajax和Axios"></a>Ajax和Axios</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li><p>Axios是一个基于Promise的HTTP库，而Ajax是对原生XHR的封装；</p></li><li><p>Ajax技术实现了局部数据的刷新，而Axios实现了对ajax的封装。</p></li></ol><h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>Ajax是对原生XHR的封装，为了达到我们跨越的目的，增添了对JSONP的支持。</p><p>异步的javascript和xml，ajax不是一门新技术，而是多种技术的组合，用于快速的创建动态页面，能够实现无刷新更新数据从而提高用户体验。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li><p>无刷新更新数据</p></li><li><p>异步与服务器通信</p></li><li><p>前端和后端负载平衡</p></li><li><p>基于标准被广泛支</p></li><li><p>界面与应用分离</p></li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>ajax不能使用Back和history功能，即对浏览器机制的破坏。</li><li>安全问题 ajax暴露了与服务器交互的细节</li><li>对收索引擎的支持比较弱</li><li>破坏程序的异常处理机制</li><li>违背URL和资源定位的初衷</li><li>ajax不能很好的支持移动设备</li><li>太多客户端代码造成开发上的成本</li></ol><h4 id="请求步骤"><a href="#请求步骤" class="headerlink" title="请求步骤"></a>请求步骤</h4><ul><li><p>创建XMLHttpRequest异步对象</p></li><li><p>设置回调函数</p></li><li><p>使用open方法与服务器建立连接</p></li><li><p>向服务器发送数据</p></li><li><p>在回调函数中针对不同的响应状态进行处理</p></li></ul><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><h4 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h4><p>Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中</p><h2 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>ECMAScript: 定义核心语法，关键字，运算符等系列标准</li><li>DOM：文档对象模型<ul><li>专注于文档内容的结构化表示，允许你操作页面的元素和内容。</li></ul></li><li>BOM：浏览器对象模型<ul><li>主要涉及浏览器窗口和环境的控制，与浏览器交互的功能。</li><li>常见应用：<ul><li>控制窗口和弹出窗口：window</li><li>操作浏览器历史记录：history</li><li>动态URL操作：location</li><li>检测用户环境：navigator</li><li>获取屏幕信息：screen</li></ul></li></ul></li></ul><h2 id="webpack动态导入模块"><a href="#webpack动态导入模块" class="headerlink" title="webpack动态导入模块"></a>webpack动态导入模块</h2><p>在 JavaScript 的注释中指定 <code>webpackChunkName</code>，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "home" */</span> <span class="string">'./Home.vue'</span>)</span><br></pre></td></tr></table></figure><p>这行代码告诉 Webpack，在构建过程中将 <code>./Home.vue</code> 模块打包为名为 <code>home.js</code> 的代码块，而不是使用自动生成的名字。</p><h3 id="根据路由动态加载组件"><a href="#根据路由动态加载组件" class="headerlink" title="根据路由动态加载组件"></a>根据路由动态加载组件</h3><h4 id="使用-Vue-Router-和-Webpack-的动态导入"><a href="#使用-Vue-Router-和-Webpack-的动态导入" class="headerlink" title="使用 Vue Router 和 Webpack 的动态导入"></a>使用 Vue Router 和 Webpack 的动态导入</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* router/index.js */</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "home" */</span> <span class="string">'../views/Home.vue'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/about'</span>,</span><br><span class="line">    component: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: "about" */</span> <span class="string">'../views/About.vue'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul><li>当用户导航到 <code>/home</code> 时，<code>Home.vue</code> 组件会被动态加载。</li><li>Webpack 将 <code>Home.vue</code> 及其依赖打包为一个名为 <code>home.js</code> 的代码块。</li><li>同样，当用户导航到 <code>/about</code> 时，<code>About.vue</code> 会被动态加载，并生成 <code>about.js</code>。</li></ul><h3 id="编译结果"><a href="#编译结果" class="headerlink" title="编译结果"></a>编译结果</h3><p>在编译完成后，Webpack 会在 <code>dist</code> 文件夹中生成多个代码块文件，其中 <code>home.js</code> 和 <code>about.js</code> 是通过动态导入生成的。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dist/</span><br><span class="line">  ├── app.js           // 应用的主文件</span><br><span class="line">  ├── vendor.js        // 第三方库和框架</span><br><span class="line">  ├── home.js          // 'home' 代码块</span><br><span class="line">  ├── about.js         // 'about' 代码块</span><br><span class="line">  └── ...</span><br></pre></td></tr></table></figure><h3 id="使用-webpackChunkName-的好处"><a href="#使用-webpackChunkName-的好处" class="headerlink" title="使用 webpackChunkName 的好处"></a>使用 <code>webpackChunkName</code> 的好处</h3><ol><li><strong>可读性</strong>：指定的名字更具可读性，方便调试和分析。</li><li><strong>维护性</strong>：更容易追踪和管理代码块。</li><li><strong>性能优化</strong>：配合其他 Webpack 功能，如缓存优化，可以进一步提高加载性能。</li></ol><h2 id="querySelector与getElementById"><a href="#querySelector与getElementById" class="headerlink" title="querySelector与getElementById"></a>querySelector与getElementById</h2><h3 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector"></a>querySelector</h3><ul><li><p>使用 <strong>CSS 选择器</strong> 语法，支持选择器的所有功能，包括类选择器、ID 选择器、属性选择器、伪类、组合选择器等。</p></li><li><p>可以选择文档中任意元素的第一个匹配项，灵活性高。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.querySelector(<span class="string">'.my-class'</span>); <span class="comment">// 选择第一个具有 "my-class" 类的元素</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.querySelector(<span class="string">'#my-id'</span>); <span class="comment">// 选择具有 "my-id" ID 的元素</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.querySelector(<span class="string">'div[data-type="example"]'</span>); <span class="comment">// 选择具有特定属性的第一个 div 元素</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById"></a>getElementById</h3><ul><li><p>仅接受元素的 <strong>ID 选择器</strong>（不带 <code>#</code>）。</p></li><li><p>只能选择具有指定 ID 的单个元素。</p></li><li><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'my-id'</span>); <span class="comment">// 选择具有 "my-id" ID 的元素</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Theme-Snail</title>
      <link href="/2019/11/01/Hexo-Theme-Snail/"/>
      <url>/2019/11/01/Hexo-Theme-Snail/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-theme-snail"><a href="#hexo-theme-snail" class="headerlink" title="hexo-theme-snail"></a>hexo-theme-snail</h1><p><a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">View Hexo-Theme-Snail Sources On Github &#10174; </a></p><p><a href="https://www.dusign.net" target="_blank" rel="noopener">View Live Super Snail Blog &#10174;</a></p><p><img src="snail.png" alt="hexo-theme-snail"></p><p>Hexo-theme-snail is a succinct hexo theme. It has two colors, light and star, that can be set according to your own preferences in the settings, and also has the functions of sharing and commenting. More features are under development.</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>light color theme and star theme</li><li>diversified comment system</li><li>notice tips</li><li>share to other platforms (under development)</li><li>picture sharing (under development)</li></ul><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="Setup-your-blog"><a href="#Setup-your-blog" class="headerlink" title="Setup your blog"></a>Setup your blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><h3 id="Installation-Theme"><a href="#Installation-Theme" class="headerlink" title="Installation Theme"></a>Installation Theme</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ rm -rf <span class="built_in">source</span></span><br><span class="line">$ rm _config.yml package.json README.md LICENSE</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/dusign/hexo-theme-snail.git</span><br><span class="line">$ mv ./hexo-theme-snail/snail ./themes</span><br><span class="line">$ mv ./hexo-theme-snail/* ./</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="Set-Theme"><a href="#Set-Theme" class="headerlink" title="Set Theme"></a>Set Theme</h3><p>Modify the value of <code>theme:</code> in <code>_config.yml</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure></p><h3 id="Start-the-Server"><a href="#Start-the-Server" class="headerlink" title="Start the Server"></a>Start the Server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><h3 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h3><p>Replace the following information with your own.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> </span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">At</span> <span class="string">the</span> <span class="string">bottom</span> <span class="string">of</span> <span class="string">the</span> <span class="string">well,</span> <span class="string">it</span> <span class="string">is</span> <span class="string">destined</span> <span class="string">to</span> <span class="string">see</span> <span class="string">only</span> <span class="string">the</span> <span class="string">sky</span> <span class="string">at</span> <span class="string">the</span> <span class="string">wellhead.</span> </span><br><span class="line">          <span class="string">However,</span> <span class="string">the</span> <span class="string">starting</span> <span class="string">point</span> <span class="string">only</span> <span class="string">affects</span> <span class="string">the</span> <span class="string">process</span> <span class="string">of</span> <span class="string">reaching</span> <span class="string">your</span> <span class="string">peak</span> <span class="string">and</span> <span class="string">does</span> <span class="string">not</span> <span class="string">determine</span> <span class="string">the</span> <span class="string">height</span> <span class="string">you</span> <span class="string">reach.</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Dusign</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure></p><h3 id="Site-Settings"><a href="#Site-Settings" class="headerlink" title="Site Settings"></a>Site Settings</h3><p>Put customized pictures in <code>img</code> directory.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site settings</span></span><br><span class="line"><span class="attr">SEOTitle:</span> <span class="string">Hexo-theme-snail</span></span><br><span class="line"><span class="attr">email:</span> <span class="string">hexo-theme-snail@mail.com</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"A hexo theme"</span></span><br><span class="line"><span class="attr">keyword:</span> <span class="string">"dusign, hexo-theme-snail"</span></span><br><span class="line"><span class="attr">header-img:</span> <span class="string">img/header_img/home-bg-1-dark.jpg</span></span><br><span class="line"><span class="attr">signature:</span> <span class="literal">true</span> <span class="comment">#show signature</span></span><br><span class="line"><span class="attr">signature-img:</span> <span class="string">img/signature/Just-do-it-white.png</span></span><br></pre></td></tr></table></figure></p><h3 id="SNS-Settings"><a href="#SNS-Settings" class="headerlink" title="SNS Settings"></a>SNS Settings</h3><p>If you don’t want to display it, you can delete it directly.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SNS settings</span></span><br><span class="line"><span class="attr">github_username:</span>    <span class="string">dusign</span></span><br><span class="line"><span class="attr">twitter_username:</span>   <span class="string">dusignr</span></span><br><span class="line"><span class="attr">facebook_username:</span>  <span class="string">Gang</span> <span class="string">Du</span></span><br><span class="line"><span class="attr">zhihu_username:</span> <span class="string">dusignr</span></span><br></pre></td></tr></table></figure></p><h3 id="Sidebar-Settings"><a href="#Sidebar-Settings" class="headerlink" title="Sidebar Settings"></a>Sidebar Settings</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="attr">sidebar:</span> <span class="literal">true</span>                      <span class="comment"># whether or not using Sidebar.</span></span><br><span class="line"><span class="attr">sidebar-about-description:</span> <span class="string">"Welcome to visit, I'm Dusign!"</span></span><br><span class="line"><span class="attr">sidebar-avatar:</span> <span class="string">img/ironman-draw.png</span>      <span class="comment"># use absolute URL, seeing it's used in both `/` and `/about/`</span></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">featured-tags</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">short-about</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">recent-posts</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">friends-blog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">archive</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">category</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># widget behavior</span></span><br><span class="line"><span class="comment">## Archive</span></span><br><span class="line"><span class="attr">archive_type:</span> <span class="string">'monthly'</span></span><br><span class="line"><span class="attr">show_count:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Featured Tags</span></span><br><span class="line"><span class="attr">featured-tags:</span> <span class="literal">true</span>                     <span class="comment"># whether or not using Feature-Tags</span></span><br><span class="line"><span class="attr">featured-condition-size:</span> <span class="number">1</span>              <span class="comment"># A tag will be featured if the size of it is more than this condition value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Friends</span></span><br><span class="line"><span class="attr">friends:</span> <span class="string">[</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Blog"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://blog.csdn.net/d_Nail"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Web"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Github"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://github.com/dusign"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Other"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">      <span class="attr">github:</span> <span class="string">github.repository.address</span></span><br><span class="line">      <span class="attr">coding:</span> <span class="string">coding.repository.address</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>See httpymls://github.com/imsun/gitment for detailed configuration method.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line"><span class="comment">## This comment system is gitment</span></span><br><span class="line"><span class="comment">## gitment url: https://github.com/imsun/gitment</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">  <span class="attr">client_id:</span></span><br><span class="line">  <span class="attr">client_secret:</span></span><br></pre></td></tr></table></figure></p><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tip</span></span><br><span class="line"><span class="attr">tip:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">content:</span> <span class="string">欢迎访问</span> <span class="string">&lt;a</span> <span class="string">href="https://www.dusign.net"</span> <span class="string">target="dusign"&gt;dusign&lt;/a&gt;</span> <span class="string">的博客，博客系统一键分享的功能还在完善中，请大家耐心等待。</span></span><br><span class="line">          <span class="string">若有问题或者有好的建议欢迎留言，笔者看到之后会及时回复。</span></span><br><span class="line">          <span class="string">评论点赞需要github账号登录，如果没有账号的话请点击</span> </span><br><span class="line">          <span class="string">&lt;a</span> <span class="string">href="https://github.com"</span> <span class="string">target="view_window"</span> <span class="string">&gt;</span> <span class="string">github</span> <span class="string">&lt;/a&gt;</span> <span class="string">注册，</span> <span class="string">谢谢</span> <span class="string">!</span></span><br></pre></td></tr></table></figure><h3 id="Color-Sheme"><a href="#Color-Sheme" class="headerlink" title="Color Sheme"></a>Color Sheme</h3><p>Set the <code>enable</code> value of the desired color sheme to <code>true</code>. If the value of <code>bg_effects.star.enable</code> is <code>true</code>, please modify the value of <code>highlight_theme</code> in <code>./themes/snail/_config.yml</code> to <code>night</code>.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Color Sheme</span></span><br><span class="line"><span class="comment">## If there is no effect after modification, please empty the cache and try again.</span></span><br><span class="line"><span class="comment">## ⚠️ The following special effects will take up a lot of cpu resorces, please open it carefully.</span></span><br><span class="line"><span class="attr">bg_effects:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">color:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">pointColor:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">opacity:</span> <span class="number">0.7</span></span><br><span class="line">    <span class="attr">zIndex:</span> <span class="number">-9</span></span><br><span class="line">    <span class="attr">count:</span> <span class="number">99</span></span><br><span class="line">  <span class="attr">mouse_click:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">'"🌱","just do it","🌾","🍀","don'</span><span class="string">'t give up","🍂","🌻","try it again","🍃","never say die","🌵","🌿","🌴"'</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">'"rgb(121,93,179)"</span></span><br><span class="line"><span class="string">          ,"rgb(76,180,231)"</span></span><br><span class="line"><span class="string">          ,"rgb(184,90,154)"</span></span><br><span class="line"><span class="string">          ,"rgb(157,211,250)"</span></span><br><span class="line"><span class="string">          ,"rgb(255,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(242,153,29)"</span></span><br><span class="line"><span class="string">          ,"rgb(23,204,16)"</span></span><br><span class="line"><span class="string">          ,"rgb(222,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(22,36,92)"</span></span><br><span class="line"><span class="string">          ,"rgb(127,24,116)"</span></span><br><span class="line"><span class="string">          ,"rgb(119,195,79)"</span></span><br><span class="line"><span class="string">          ,"rgb(4,77,34)"</span></span><br><span class="line"><span class="string">          ,"rgb(122,2,60)"'</span></span><br><span class="line">  <span class="attr">star:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h2 id="Releases"><a href="#Releases" class="headerlink" title="Releases"></a>Releases</h2><p>V1.0</p><ul><li>fix the bugs</li><li>add comment system</li><li>add notice tips</li><li>add star sheme</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Apache License 2.0 Copyright(c) 2018-2020 <a href="https://github.com/dusign" target="_blank" rel="noopener">Dusign</a>   </p><p><a href="https://github.com/dusign/hexo-theme-snail" target="_blank" rel="noopener">hexo-theme-snail</a> is derived from <a href="https://github.com/Huxpro/huxpro.github.io" target="_blank" rel="noopener">Huxpro</a> Apache License 2.0. Copyright (c) 2015-2020 Huxpro</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo-theme-snail </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
